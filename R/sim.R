#' Simulate model coefficients
#'
#' @description `sim()` simulates model parameters from a multivariate normal or t distribution that are then used by [sim_apply()] to calculate quantities of interest.
#'
#' @param fit a model fit, such as the output of a call to [lm()] or [glm()]. Can be left unspecified if `coefs` and `vcov` are not functions.
#' @param n the number of simulations to run; default is 1000. More is always better but resulting calculations will take longer.
#' @param vcov either a square covariance matrix of the parameter estimates or a function to use to extract it from `fit`. By default, uses [stats::vcov()].
#' @param coefs either a vector of coefficient estimates or a function to use to extract it from `fit`. By default, uses [stats::coef()]. Using anything but the default changes some options in `sim_apply()`; see [sim_apply()]'s Details section for more information.
#' @param dist a string containing the name of the multivariate distribution to use to draw simulated coefficients. Should be one of `"normal"` (multivariate normal distribution) or `"t_{#}"` (multivariate t distribution), where `{#}` corresponds to the desired degrees of freedom (e.g., `"t_100"`). If `NULL`, `sim()` will attempt to figure out the right distribution to use; see Details.
#'
#' @return A `simbased_sim` object, which has the following components:
#'  \item{coefs}{a matrix containing the simulated coefficients with a column for each coefficient and a row for each simulation}
#'  \item{fit}{the original model fit supplied to}
#' The `"dist"` attribute contains `"normal"` if the coefficients were sampled from a multivariate normal distribution and `"t"` if sampled from a mutivariate t distribution. The `"simbased_hash"` attribute contains a unique hash generated by [rlang::hash()].
#'
#' @details When `dist` is `NULL`, `sim()` samples from a multivariate normal or t distribution depending on whether `df.residual(fit)` is `NULL` or not. If `NULL` or `fit` is unspecified, a multivariate normal distribution is used. Otherwise (primarily for linear models fit with `lm()`), a multivariate t distribution is used, with `df.residual(fit)` used as the degrees of freedom.
#'
#' When a multivariate normal is used, it is sampled from with means equal to the estimated coefficients and the parameter covariance matrix as the covariance matrix using [mvnfast::rmvn()]. When a multivariate t distribution is used, it is sampled from with means equal to the estimated coefficients and scaling matrix equal to `cov*(df - 2)/df`, where `cov` is the parameter covariance matrix and `df` is the residual degrees of freedom for the model, using [mvnfast::rmvt()].
#'
#' @seealso
#' * [sim_apply()] for applying a function to each set of simulated coefficients.
#' * [sim_ame()] for computing average marginal effects in each simulation draw
#' * [sim_setx()] for computing marginal predictions and first differences at typical values in each simulation draw
#'
#' @examples
#'
#' data("lalonde", package = "MatchIt")
#' fit <- lm(re78 ~ treat * (age + race + nodegree + re74), data = lalonde)
#'
#' # Simulate coefficients
#' s <- sim(fit)
#' s
#'
#' ## Could also use a robust covariance matrix, e.g.,
#' # s <- sim(fit, vcov = sandwich::vcovHC)
#'
#' # Simulated coefficients assuming a normal distribution
#' # for coefficients; default for `lm` objects is a t-
#' # distribution
#' s <- sim(fit, dist = "normal")
#' s
#'
#' @export
sim <- function(fit,
                n = 1e3,
                vcov = stats::vcov,
                coefs = stats::coef,
                dist = NULL) {

  if (missing(fit)) fit <- NULL

  use.fit <- !is.null(fit)

  if (is.function(coefs)) {
    if (is.null(fit)) {
      chk::err("`fit` must be supplied when `coefs` is a function")
    }
    # if (!identical(coefs, stats::coef)) {
    #   use.fit <- FALSE
    # }
    coefs <- coefs(fit)
    if (!check_valid_coef(coefs)) {
      chk::err("the output of the function supplied to `coefs` must be a numeric vector")
    }
  }
  else if (!check_valid_coef(coefs)) {
    chk::err("`coefs` must be a vector of coefficients or a function that extracts one from `fit`")
  }

  if (is.function(vcov)) {
    if (is.null(fit)) {
      chk::err("`fit` must be supplied when `vcov` is a function")
    }
    vcov <- vcov(fit)
    if (is.null(dim(vcov)) || !all(dim(vcov) == length(coefs))) {
      chk::err("the output of the function supplied to `vcov` must be a square matrix with dimensions equal to the number of coefficients")
    }
  }
  else if (is.matrix(vcov) && is.numeric(vcov)) {
    if (is.null(dim(vcov)) || !all(dim(vcov) == length(coefs))) {
      chk::err("when supplied as a matrix, `vcov` must be a square matrix with dimensions equal to the number of coefficients`")
    }
  }
  else {
    chk::err("`vcov` must be a covariance matrix or a function that extracts one from `fit`")
  }

  chk::chk_count(n)

  sampler <- get_sampling_dist(fit, dist)

  out <- list(sim.coefs = sampler(n, coefs, vcov),
              coefs = coefs,
              vcov = vcov,
              fit = fit)

  attr(out, "dist") <- attr(sampler, "dist")
  attr(out, "use.fit") <- use.fit
  attr(out, "sim_hash") <- rlang::hash(out)
  class(out) <- "simbased_sim"

  out
}

#' @export
print.simbased_sim <- function(x, ...) {
  cat("A simbased_sim object\n")
  cat(sprintf(" - %s coefficients, %s simulated values\n", ncol(x$sim.coefs), nrow(x$sim.coefs)))
  cat(sprintf(" - sampled distribution: multivariate %s\n", attr(x, "dist")))
  cat(" - original fitting function call:\n\n")
  print(insight::get_call(x$fit))
}

get_sampling_dist <- function(fit = NULL, dist = NULL) {

  if (!is.null(dist)) {
    chk::chk_string(dist)
    dist <- tolower(dist)
    if (startsWith(dist, "t_")) {
      df <- substr(dist, 3, nchar(dist))
      if (nchar(df) == 0 || anyNA(suppressWarnings(df <- as.numeric(df))) || !chk::vld_number(df)) {
        chk::err("when `dist` is supplied as t_{#}, `{#}` must be a number")
      }
      df <- as.numeric(df)
      dist <- "t"
    }
    else if (!anyNA(pmatch(dist, "normal"))) {
      dist <- "normal"
    }
    else {
      chk::err("`dist` must be \"normal\" or \"t_{#}\", where `{#}` corresponds to the desired degrees of freedom")
    }
  }
  else if (is.null(fit)) {
    dist <- "normal"
  }
  else {
    if (inherits(fit, "glm")) df <- NULL
    else {
      df <- try(stats::df.residual(fit), silent = TRUE)
      if (inherits(df, "try-error")) df <- NULL
    }

    if (is.null(df)) df <- Inf

    if (any(is.finite(df)) && all(df > 0)) dist <- "t"
    else dist <- "normal"
  }

  if (dist == "t") {
    f <- function(n, mu, cov) {
      sigma <- cov*(df - 2)/df
      mvnfast::rmvt(n, mu = mu, sigma = sigma, df = df, kpnames = TRUE)
    }
  }
  else {
    f <- function(n, mu, cov) {
      mvnfast::rmvn(n, mu = mu, sigma = cov, kpnames = TRUE)
    }
  }

  attr(f, "dist") <- dist

  return(f)
}

