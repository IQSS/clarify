<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>`clarify`: Simulation-Based Inference for Regression Models • clarify</title>
<!-- mathjax math --><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script><script>
  window.MathJax = {
    chtml: {
      fontURL: "https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/output/chtml/fonts/woff-v2"
    }
  };
</script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="`clarify`: Simulation-Based Inference for Regression Models">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">clarify</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.2.2</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item"><a class="nav-link" href="../articles/clarify.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/Zelig.html">Translating Zelig to clarify</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/iqss/clarify/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>`clarify`: Simulation-Based Inference for Regression Models</h1>
            
            <h4 data-toc-skip class="date">2025-09-19</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/iqss/clarify/blob/main/vignettes/clarify.Rmd" class="external-link"><code>vignettes/clarify.Rmd</code></a></small>
      <div class="d-none name"><code>clarify.Rmd</code></div>
    </div>

    
    
<p><em>Note: This is an updated version of the</em> R Journal <a href="https://doi.org/10.32614/RJ-2024-015" class="external-link"><em>article</em></a>
<em>about <strong>clarify</strong>. Please cite that article when citing
the package. Use <code>citation("clarify")</code> to generate a
citation.</em></p>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Although regression models are frequently used in empirical research
to study relationships among variables, often the quantity of
substantive interest is not one of the coefficients of the model, but
rather a quantity derived from the coefficients, such as predicted
values or average marginal effects. Quantifying the uncertainty of these
derived quantities (i.e., computing standard errors, confidence
intervals, and p-values) requires additional processing. Several methods
of doing so exist, including the delta method, the bootstrap, and
simulation-based inference. <strong>clarify</strong> implements
simulation-based inference, which we describe below along with these
other methods.</p>
<p>The delta method involves computing a first-order Taylor series
approximation to the variance of the derived quantity, and standard
Wald-based inference relies on computing quantiles based on the Normal
distribution and using them to compute p-values and confidence
intervals. <strong>clarify</strong> implements an alternative to the
delta method—simulation-based inference—which involves simulating a
“posterior” distribution of the derived quantities. Simulation-based
inference does not require understanding Taylor series or the calculus
that underlies it, which can make it more palatable to nontechnical
audiences and easier to learn for students without necessarily
sacrificing statistical performance <span class="citation">(<a href="#ref-kingMakingMostStatistical2000">King, Tomz, and Wittenberg
2000</a>; <a href="#ref-zelnerUsingSimulationInterpret2009">Zelner
2009</a>)</span>. Some studies have found that simulation-based
inference performs as well or better than the delta method for computing
derived quantities (i.e., with respect to achieving close to nominal
coverage for confidence intervals), especially for complicated derived
quantities and in smaller samples <span class="citation">(<a href="#ref-mackinnonConfidenceLimitsIndirect2004">MacKinnon, Lockwood,
and Williams 2004</a>; <a href="#ref-holeComparisonApproachesEstimating2007">Hole 2007</a>; <a href="#ref-herronPostestimationUncertaintyLimited1999">Herron
1999</a>)</span>. Its empirical performance has been particularly well
studied in the context of mediation analysis, in which the quantities of
interest are products and ratios of regression coefficients, where it
has been shown to perform well relative to the delta method due to the
non-Normality of these quantities <span class="citation">(<a href="#ref-tofighiMonteCarloConfidence2016">Tofighi and MacKinnon
2016</a>; <a href="#ref-preacherAdvantagesMonteCarlo2012">Preacher and
Selig 2012</a>)</span>.</p>
<p>The methodology <strong>clarify</strong> relies on was developed by
<span class="citation">Krinsky and Robb (<a href="#ref-krinsky1986">1986</a>)</span> and is described in <span class="citation">King, Tomz, and Wittenberg (<a href="#ref-kingMakingMostStatistical2000">2000</a>)</span> and <span class="citation">Herron (<a href="#ref-herronPostestimationUncertaintyLimited1999">1999</a>)</span>.
Simulation-based inference involves taking draws from a specified joint
distribution of model parameters, computing derived quantities from
these draws, and collecting the derived quantities in a “posterior”
distribution, from which uncertainty measures (standard errors and
confidence intervals) can be computed. This method assumes the model
parameters are drawn from a multivariate Normal (or T) distribution with
means at the estimated values and covariance equal to the asymptotic
covariance matrix of the estimated values, a standard assumption
motivated by the central limit theorem that underlies usual inference on
the original model parameters. Arriving at the posterior distribution
does not require taking any derivatives or making any approximations
beyond those usually used for inference on model parameter estimates,
except for the approximation due to Monte Carlo error induced by
sampling from a finite number of simulations (which can always be
reduced by increasing the number of draws at the cost of increased
computing time).</p>
<p>The nonparametric bootstrap is another alternative to the delta
method for inference that does not require its analytic approximations
<span class="citation">(<a href="#ref-efronBootstrapMethodsStandard1986">Efron and Tibshirani
1986</a>)</span>; bootstrapping typically involves re-sampling
individuals from the sample, fitting the model in each bootstrap sample,
and computing the quantity of interest from each model. Although
bootstrapping tends to work well in practice, especially for complex and
non-Normal estimators, refitting the model repeatedly can be
prohibitively time-consuming and computationally expensive, especially
for complicated models or large datasets. Simulation-based inference
only requires the model to be fit once, and the simulations involve
taking draws from a distribution produced from the single set of
estimated parameters, making it much quicker in practice and allowing
the user to capitalize on the already valid estimation of the model
parameters. Methods for computing valid confidence intervals in cases
when the quantity of interest has a complicated distribution are better
developed when bootstrapping, however <span class="citation">(<a href="#ref-efronBootstrapMethodsStandard1986">Efron and Tibshirani
1986</a>)</span>.</p>
<p>More formally, we fit a regression model <span class="math inline">\(y_i = f(x_i; \beta)\)</span>, such as a linear or
other generalized linear model with model coefficients <span class="math inline">\(\beta\)</span>. We assume <span class="math inline">\(\hat{\beta} \sim \text{MVN}(\beta,
\Sigma_{\hat{\beta}})\)</span> where <span class="math inline">\(\hat{\beta}\)</span> is the vector of estimates of
<span class="math inline">\(\beta\)</span> and <span class="math inline">\(\Sigma_{\hat{\beta}}\)</span> is their asymptotic
covariance matrix. We define a function <span class="math inline">\(\tau(\beta)\)</span> that represents a quantity of
interest derived from the model parameters, and compute its estimate
<span class="math inline">\(\widehat{\tau(\beta)}\)</span> as <span class="math inline">\(\tau(\hat{\beta})\)</span>.</p>
<p>To perform simulation-based inference, we take <span class="math inline">\(M\)</span> draws <span class="math inline">\(\tilde{\beta}^{(j)}\)</span> for <span class="math inline">\(j\in(1, \dots, M)\)</span> from a multivariate
Normal distribution with mean vector <span class="math inline">\(\mu =
\hat{\beta}\)</span> and covariance <span class="math inline">\(\Sigma =
\hat{\Sigma}_{\hat{\beta}}\)</span>, where <span class="math inline">\(\hat{\Sigma}_{\hat{\beta}}\)</span> is an estimate
of the asymptotic covariance matrix of the parameter estimates. We use
the distribution of <span class="math inline">\(\tilde{\tau}=\tau(\tilde{\beta})\)</span> as the
“posterior” distribution of <span class="math inline">\(\widehat{\tau(\beta)}\)</span>, and compute its
variance as <span class="math display">\[\begin{equation}
\hat\sigma^2_{\widehat{\tau(\beta)}} =
\frac{1}{M-1}\sum^M_{j=1}{(\tilde{\tau}^{(j)} - \bar{\tilde{\tau}})^2}
\end{equation}\]</span> and quantile <span class="math inline">\(100(1-\alpha)\%\)</span> confidence interval
limits as <span class="math inline">\(\left[\tilde{\tau}_{(\frac{\alpha}{2})},
\tilde{\tau}_{(1-\frac{\alpha}{2})}\right]\)</span> where <span class="math inline">\(\tilde{\tau}_{(q)}\)</span> is the <span class="math inline">\(q\)</span>th value of <span class="math inline">\(\tilde{\tau}\)</span> when arranged in ascending
order (i.e., the <span class="math inline">\(q\)</span>th quantile of
the empirical cumulative distribution function of <span class="math inline">\(\tilde{\tau}\)</span>). Simulation-based Wald-type
confidence intervals can be computed as <span class="math display">\[\begin{equation}
\left[\tau(\hat{\beta}) + \hat\sigma_{\widehat{\tau(\beta)}}
Z_{\frac{\alpha}{2}}, \tau(\hat{\beta}) +
\hat\sigma_{\widehat{\tau(\beta)}} Z_{1-\frac{\alpha}{2}} \right]
\end{equation}\]</span> where <span class="math inline">\(Z_q\)</span>
is the <span class="math inline">\(q\)</span>th quantile of a standard
Normal distribution. The delta method-based Wald-type confidence
intervals use this formula but with the first-order Taylor approximation
to the asymptotic variance: <span class="math display">\[\begin{equation}
\hat\sigma^2_{\widehat{\tau(\beta)}}=\nabla\tau(\hat{\beta})
\Sigma_{\hat{\beta}} \nabla\tau'(\hat{\beta})
\end{equation}\]</span> where <span class="math inline">\(\nabla\tau(\hat{\beta})\)</span> is the gradient
of <span class="math inline">\(\tau(\beta)\)</span> with respect to
<span class="math inline">\(\beta\)</span> evaluated at <span class="math inline">\(\hat{\beta}\)</span>.</p>
<p>To compute a p-value for a hypothesis test involving the quantity of
interest, i.e., <span class="math inline">\(\text{H}_0: \tau (\beta) =
\tau_0\)</span> with a given null value <span class="math inline">\(\tau_0\)</span>, we can invert the confidence
interval <span class="citation">(<a href="#ref-thulinModernStatisticsWrangling2021">Thulin 2024</a>)</span>;
that is, we find the largest value of <span class="math inline">\(\alpha\)</span> such that <span class="math inline">\(\tau_0\)</span> is within the confidence interval
and use that <span class="math inline">\(\alpha\)</span> as the p-value
for the test. For Wald-based inference (either using the
simulation-based variance or delta method-based variance), this is
equivalent to performing a standard two-sided Z-test using the test
statistic <span class="math display">\[\begin{equation}
Z=\frac{\tau(\hat\beta)-\tau_0}{\hat\sigma_{\widehat{\tau(\beta)}}}
\end{equation}\]</span> One benefit of using the quantile p-values for
inference is that equivalent tests of the same hypothesis will always
yield identical p-values; for example, testing the equality of two
derived quantities will yield the same p-value when comparing the
difference between the quantities against a null hypothesis of 0 and the
ratio of the quantities against a null hypothesis of 1, as each of these
hypothesis is true if and only if the other is true.</p>
<p>One would expect simulation-based quantile inference,
simulation-based Wald inference, and delta method-based Wald inference
to align when the posterior is Normally distributed around the estimate,
in which case any discrepancies would be due to Monte Carlo error in the
simulated values (and therefore would shrink with increasing draws).
However, for low values of <span class="math inline">\(\alpha\)</span>,
it may require many draws for the simulation-based intervals to
stabilize; delta method-based intervals are not subject to this error.
There are a few cases in which the results might diverge: in some cases,
the first-order Taylor series approximation to the variance may be poor,
though in practice the approximation error is small and shrinks quickly
with increasing sample size. When the posterior distribution is
non-Normal but symmetric around the estimate, the quantile intervals may
be more accurate (i.e., in the sense of achieving closer to nominal
coverage) because they do not rely on quantiles from the Normal
distribution <span class="citation">(<a href="#ref-tofighiMonteCarloConfidence2016">Tofighi and MacKinnon
2016</a>)</span>.</p>
<p>Another potential advantage quantile intervals can have over
Wald-intervals is that when <em>some</em> monotonic transformation of
the estimate has a symmetric distribution centered around the
transformed estimate, the quantile intervals can achieve correct
coverage without requiring knowledge of <em>which</em> transformation is
required <span class="citation">(<a href="#ref-efronBootstrapMethodsStandard1986">Efron and Tibshirani
1986</a>)</span>; this is true of the quantile-based p-values as well.
When the distribution is not centered around the estimate and no
monotonic transformation will make it so, though, neither quantile-based
nor Wald-based intervals would be expected to perform well, and quantile
intervals could yield even worse coverage than Wald-based intervals, a
phenomenon that occurs in the context of bootstrapping <span class="citation">(<a href="#ref-efronBootstrapMethodsStandard1986">Efron
and Tibshirani 1986</a>)</span><a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;We thank an anonymous reviewer for pointing out a
scenario in which this could occur: for a quantity of interest with a
right-skewed sampling distribution, one would prefer an estimate to the
right of the quantity’s true value to have a confidence interval skewed
to left to capture the bulk of the sampling distribution, but in
practice a quantile confidence interval would also be skewed to the
right. While a symmetric Wald-based interval may not have adequate
coverage, the quantile-based interval could perform even worse.&lt;/p&gt;"><sup>1</sup></a>. An informal falsification test for whether
such a monotonic transformation exists is whether the median of the
simulated estimates is aligned with the point estimate; if it is not,
there is no monotonic transformation that will yield a symmetric
quantile interval with the desired coverage.</p>
</div>
<div class="section level2">
<h2 id="related-software">Related software<a class="anchor" aria-label="anchor" href="#related-software"></a>
</h2>
<p>Similar functionality exists in the <strong>CLARIFY</strong> package
in Stata<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;Despite the similar name, the R package
&lt;strong&gt;clarify&lt;/strong&gt; and the Stata package &lt;strong&gt;CLARIFY&lt;/strong&gt;
differ in several ways, one of which is that the estimates reported by
&lt;strong&gt;clarify&lt;/strong&gt; in R are those computed using the original
model coefficients, whereas those reported by &lt;strong&gt;CLARIFY&lt;/strong&gt;
in Stata are those computed as the average of the simulated
distribution. The R implementation avoids the “simulation-induced bias”
described by &lt;span class="citation"&gt;Rainey (&lt;a href="#ref-raineyCarefulConsiderationCLARIFY2023"&gt;2023&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;'><sup>2</sup></a>
<span class="citation">(<a href="#ref-tomzClarifySoftwareInterpreting2003">Tomz, Wittenberg, and
King 2003</a>)</span> and used to be available in the
<strong>Zelig</strong> R package <span class="citation">(<a href="#ref-imaiCommonFrameworkStatistical2008a">Imai, King, and Lau
2008</a>)</span>, though there are differences in these implementations.
<strong>clarify</strong> provides additional flexibility by allowing the
user to request any derived quantity, in addition to providing shortcuts
for common quantities, including predictions at representative values,
average marginal effects, and average dose-response functions (described
below). <strong>clarify</strong> relies on and can be seen as a
companion to the <strong>marginaleffects</strong> package <span class="citation">(<a href="#ref-marginaleffectsforthcoming">Arel-Bundock, Greifer, and Heiss
2024</a>)</span>, which offers similar functionality but primarily uses
the delta method for calculating uncertainty (though simulation-based
inference is supported in a more limited capacity as well).</p>
</div>
<div class="section level2">
<h2 id="using-clarify">Using <strong>clarify</strong><a class="anchor" aria-label="anchor" href="#using-clarify"></a>
</h2>
<p>There are four steps to using <strong>clarify</strong>:</p>
<ol style="list-style-type: decimal">
<li><p>Fit the model to the data using modeling functions in supported
packages.</p></li>
<li><p>Use <code><a href="../reference/sim.html">sim()</a></code> to take draws from the multivariate
distribution of the estimated model coefficients.</p></li>
<li><p>Use <code><a href="../reference/sim_apply.html">sim_apply()</a></code> or its wrappers
<code><a href="../reference/sim_setx.html">sim_setx()</a></code>, <code><a href="../reference/sim_ame.html">sim_ame()</a></code>, and
<code><a href="../reference/sim_adrf.html">sim_adrf()</a></code> to compute derived quantities using each
simulated set of coefficients.</p></li>
<li><p>Use <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> and <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> to summarize
and visualize the distribution of the derived quantities and perform
inference on them.</p></li>
</ol>
<p>In the sections below, we will describe how to implement these steps
in detail. First, we will load <strong>clarify</strong> using
<code><a href="https://rdrr.io/r/base/library.html" class="external-link">library()</a></code>.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/iqss/clarify" class="external-link">clarify</a></span><span class="op">)</span></span></code></pre></div>
<p>For a running example, we will use the <code>lalonde</code> dataset
in the <strong>MatchIt</strong> package <span class="citation">(<a href="#ref-JSSv042i08">Ho et al. 2011</a>)</span>, which contains data
on 614 participants enrolled in a job training program or sampled from a
survey <span class="citation">(<a href="#ref-dehejiaCausalEffectsNonexperimental1999">Dehejia and Wahba
1999</a>)</span>. The treatment variable is <code>treat</code> and the
outcome is <code>re78</code>, and all other variables are confounders.
Although the original use of this dataset was to estimate the effect of
<code>treat</code> on <code>re78</code>, we will use it more generally
to demonstrate all of <strong>clarify</strong>’s capabilities. In
addition, we will use a transformation of the outcome variable to
demonstrate applications to nonlinear models, for which the benefits of
simulation-based inference are more apparent.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"lalonde"</span>, package <span class="op">=</span> <span class="st">"MatchIt"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Create a binary outcome variable</span></span>
<span><span class="va">lalonde</span><span class="op">$</span><span class="va">re78_0</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html" class="external-link">ifelse</a></span><span class="op">(</span><span class="va">lalonde</span><span class="op">$</span><span class="va">re78</span> <span class="op">&gt;</span> <span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">lalonde</span><span class="op">)</span></span>
<span><span class="co">#&gt;      treat age educ   race married nodegree re74 re75       re78 re78_0</span></span>
<span><span class="co">#&gt; NSW1     1  37   11  black       1        1    0    0  9930.0460      1</span></span>
<span><span class="co">#&gt; NSW2     1  22    9 hispan       0        1    0    0  3595.8940      1</span></span>
<span><span class="co">#&gt; NSW3     1  30   12  black       0        0    0    0 24909.4500      1</span></span>
<span><span class="co">#&gt; NSW4     1  27   11  black       0        1    0    0  7506.1460      1</span></span>
<span><span class="co">#&gt; NSW5     1  33    8  black       0        1    0    0   289.7899      1</span></span>
<span><span class="co">#&gt; NSW6     1  22    9  black       0        1    0    0  4056.4940      1</span></span></code></pre></div>
<div class="section level3">
<h3 id="fitting-the-model">1. Fitting the model<a class="anchor" aria-label="anchor" href="#fitting-the-model"></a>
</h3>
<p>The first step is to fit the model. <strong>clarify</strong> can
operate on a large set of models (those supported by
<strong>marginaleffects</strong>), including generalized linear models,
multinomial models, multivariate models, and instrumental variable
models, many of which are available in other R packages. Even if
<strong>clarify</strong> does not offer direct support for a given
model, there are ways to use its functionality regardless (explained in
more detail below).</p>
<p>Because we are computing derived quantities, it is not critical to
parameterize the model in such a way that the coefficients are
interpretable, e.g., by using a model with interpretable coefficients or
centering predictors. Below, we will fit a probit regression model for
the outcome given the treatment and confounders. Coefficients in probit
regression do not have a straightforward interpretation, but that does
not matter; our quantities of interest can be expressed as derived
quantities—functions of the model parameters, such as predictions,
counterfactual predictions, and averages and contrasts of them.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm</a></span><span class="op">(</span><span class="va">re78_0</span> <span class="op">~</span> <span class="va">treat</span> <span class="op">*</span> <span class="va">married</span> <span class="op">+</span> <span class="va">age</span> <span class="op">+</span> <span class="va">educ</span> <span class="op">+</span> <span class="va">race</span> <span class="op">+</span></span>
<span>             <span class="va">nodegree</span> <span class="op">+</span> <span class="va">re74</span> <span class="op">+</span> <span class="va">re75</span>, data <span class="op">=</span> <span class="va">lalonde</span>,</span>
<span>           family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial</a></span><span class="op">(</span><span class="st">"probit"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="drawing-from-the-coefficient-distribution">2. Drawing from the coefficient distribution<a class="anchor" aria-label="anchor" href="#drawing-from-the-coefficient-distribution"></a>
</h3>
<p>After fitting the model, we will use <code><a href="../reference/sim.html">sim()</a></code> to draw
coefficients from their sampling distribution. The sampling distribution
is assumed to be multivariate Normal or multivariate T with appropriate
degrees of freedom, with a mean vector equal to the estimated
coefficients and a covariance matrix equal to the asymptotic covariance
matrix extracted from the model. The arguments to <code><a href="../reference/sim.html">sim()</a></code> are
listed below:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/sim.html">sim</a></span><span class="op">(</span>fit <span class="op">=</span> , n <span class="op">=</span> , vcov <span class="op">=</span> , coefs <span class="op">=</span> , dist <span class="op">=</span> <span class="op">)</span></span></code></pre></div>
<ul>
<li><p><code>fit</code> – the fitted model object, the output of the
call to the fitting function (e.g., <code><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm()</a></code>)</p></li>
<li><p><code>n</code> – the number of simulated values to draw; by
default, 1000. More values will yield more replicable and precise
results at the cost of speed.</p></li>
<li><p><code>vcov</code> – either the covariance matrix of the estimated
coefficients, a function used to extract it from the model (e.g.,
<code><a href="https://sandwich.R-Forge.R-project.org/reference/vcovHC.html" class="external-link">sandwich::vcovHC()</a></code> for the robust covariance matrix), or a
string or formula giving a code for extracting the covariance matrix,
which is passed to <code><a href="https://marginaleffects.com/man/r/get_vcov.html" class="external-link">marginaleffects::get_vcov()</a></code>. If left
unspecified, the default covariance matrix will be extracted from the
model.</p></li>
<li><p><code>coefs</code> – either a vector of coefficients to be
sampled or a function to extract them from the fitted model. If left
unspecified, the default coefficients will be extracted from the model.
Typically this does not need to be specified.</p></li>
<li><p><code>dist</code> – the name of the distribution from which to
draw the sampled coefficients. Can be <code>"normal"</code> for a Normal
distribution or <code>t(#)</code> for a T-distribution, where
<code>#</code> represents the degrees of freedom. If left unspecified,
<code><a href="../reference/sim.html">sim()</a></code> will decide on which distribution makes sense given
the characteristics of the model (the decision is made by
<code><a href="https://easystats.github.io/insight/reference/get_df.html" class="external-link">insight::get_df()</a></code> with <code>type = "wald"</code>).
Typically this does not need to be specified.</p></li>
</ul>
<p>If one’s model is not supported by <strong>clarify</strong>, one can
omit the <code>fit</code> argument and just specify the
<code>vcov</code> and <code>coefs</code> argument, which will draw the
coefficients from the distribution named in <code>dist</code>
(<code>"normal"</code> by default).</p>
<p><code><a href="../reference/sim.html">sim()</a></code> uses a random number generator to draw the sampled
coefficients from the sampling distribution, so a seed should be set
using <code><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed()</a></code> to ensure results are replicable across
sessions. Using more iterations (i.e., increasing <code>n</code>) yields
results that will be more stable across runs even when a seed is not
set.</p>
<p>The output of the call to <code><a href="../reference/sim.html">sim()</a></code> is a
<code>clarify_sim</code> object, which contains the sampled
coefficients, the original model fit object if supplied, and the
coefficients and covariance matrix used to sample.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Drawing 1000 simulated coefficients using an HC2 robust</span></span>
<span><span class="co"># covariance matrix</span></span>
<span><span class="va">s</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim.html">sim</a></span><span class="op">(</span><span class="va">fit</span>, n <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>         vcov <span class="op">=</span> <span class="st">"HC2"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">s</span></span>
<span><span class="co">#&gt; A `clarify_sim` object</span></span>
<span><span class="co">#&gt;  - 11 coefficients, 1000 simulated values</span></span>
<span><span class="co">#&gt;  - sampled distribution: multivariate normal</span></span>
<span><span class="co">#&gt;  - original fitting function call:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; glm(formula = re78_0 ~ treat * married + age + educ + race + </span></span>
<span><span class="co">#&gt;     nodegree + re74 + re75, family = binomial("probit"), data = lalonde)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="computing-derived-quantities">3. Computing derived quantities<a class="anchor" aria-label="anchor" href="#computing-derived-quantities"></a>
</h3>
<p>After sampling the coefficients, one can compute derived quantities
on each set of sampled coefficients and store the result, which
represents the “posterior” distribution of the derived quantity, as well
as on the original coefficients, which are used as the final estimates.
The core functionality is provided by <code><a href="../reference/sim_apply.html">sim_apply()</a></code>, which
accepts a <code>clarify_sim</code> object from <code><a href="../reference/sim.html">sim()</a></code> and a
function to compute and return one or more derived quantities, then
applies that function to each set of simulated coefficients. The
arguments to <code><a href="../reference/sim_apply.html">sim_apply()</a></code> are below:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/sim_apply.html">sim_apply</a></span><span class="op">(</span>sim <span class="op">=</span> , FUN <span class="op">=</span> , verbose <span class="op">=</span> , cl <span class="op">=</span> , <span class="va">...</span><span class="op">)</span></span></code></pre></div>
<ul>
<li><p><code>sim</code> – a <code>clarify_sim</code> object; the output
of a call to <code><a href="../reference/sim.html">sim()</a></code>.</p></li>
<li><p><code>FUN</code> – a function that takes in either a model fit
object or a vector of coefficients and returns one or more derived
quantities. The first argument should be named <code>fit</code> to take
in a model fit object or <code>coefs</code> to take in
coefficients.</p></li>
<li><p><code>verbose</code> – whether to display a progress
bar.</p></li>
<li><p><code>cl</code> – an argument that controls parallel processing,
which can be the number of cores to use or a cluster object resulting
from <code><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">parallel::makeCluster()</a></code>.</p></li>
<li><p><code>...</code> – further arguments to
<code>FUN</code>.</p></li>
</ul>
<p>The <code>FUN</code> argument can be specified in one of two ways:
either as a function that takes in a model fit object (e.g., a
<code>glm</code> or <code>lm</code> object, the output of a call to
<code><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm()</a></code> or <code><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm()</a></code>) or a function that takes in a
vector of coefficients. The latter will always work but the former only
works for supported models. When the function takes in a model fit
object, <code><a href="../reference/sim_apply.html">sim_apply()</a></code> will first insert each set of sampled
coefficients into the model fit object and then supply the modified
model to <code>FUN</code>.</p>
<p>For example, we will let our derived quantity of interest be the
predicted probability of the outcome for participant PSID1. We specify
our <code>FUN</code> function as follows:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sim_fun1</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">fit</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fit</span>, newdata <span class="op">=</span> <span class="va">lalonde</span><span class="op">[</span><span class="st">"PSID1"</span>,<span class="op">]</span>, type <span class="op">=</span> <span class="st">"response"</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>The <code>fit</code> object supplied to this function will be one in
which the coefficients have been set to their values in a draw from
their sampling distribution as generated by <code><a href="../reference/sim.html">sim()</a></code>. We then
supply the function to <code><a href="../reference/sim_apply.html">sim_apply()</a></code> to simulate the sampling
distribution of the predicted value of interest:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_apply.html">sim_apply</a></span><span class="op">(</span><span class="va">s</span>, FUN <span class="op">=</span> <span class="va">sim_fun1</span>, verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="va">est1</span></span>
<span><span class="co">#&gt; A `clarify_est` object (from `sim_apply()`)</span></span>
<span><span class="co">#&gt;  - 1000 simulated values</span></span>
<span><span class="co">#&gt;  - 1 quantity estimated:             </span></span>
<span><span class="co">#&gt;  PSID1 0.9757</span></span></code></pre></div>
<p>The resulting <code>clarify_est</code> object contains the simulated
estimates in matrix form as well as the estimate computed on the
original coefficients. We will examine the posterior distribution
shortly, but first we will demonstrate computing a derived quantity from
the coefficients directly.</p>
<p>The <code>race</code> variable is a factor, and the
<code>black</code> category is used as the reference level, so it is not
immediately clear whether there is a difference between the coefficients
<code>racehispan</code> and <code>racewhite</code>, which represent the
non-reference categories <code>hispan</code> and <code>white</code>. To
compare these two directly, we can use <code><a href="../reference/sim_apply.html">sim_apply()</a></code> to
compute a derived quantity that corresponds to the difference between
them.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sim_fun2</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">coefs</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">hispan</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/unname.html" class="external-link">unname</a></span><span class="op">(</span><span class="va">coefs</span><span class="op">[</span><span class="st">"racehispan"</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="va">white</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/unname.html" class="external-link">unname</a></span><span class="op">(</span><span class="va">coefs</span><span class="op">[</span><span class="st">"racewhite"</span><span class="op">]</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"w - h"</span> <span class="op">=</span> <span class="va">white</span> <span class="op">-</span> <span class="va">hispan</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">est2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_apply.html">sim_apply</a></span><span class="op">(</span><span class="va">s</span>, FUN <span class="op">=</span> <span class="va">sim_fun2</span>, verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="va">est2</span></span>
<span><span class="co">#&gt; A `clarify_est` object (from `sim_apply()`)</span></span>
<span><span class="co">#&gt;  - 1000 simulated values</span></span>
<span><span class="co">#&gt;  - 1 quantity estimated:               </span></span>
<span><span class="co">#&gt;  w - h -0.09956</span></span></code></pre></div>
<p>The function supplied to <code>FUN</code> can be arbitrarily
complicated and return as many derived quantities as one wants, though
the slower each run of <code>FUN</code> is, the longer it will take to
simulate the derived quantities. Using parallel processing by supplying
an argument to <code>cl</code> can sometimes dramatically speed up
evaluation.</p>
<p>There are several functions in <strong>clarify</strong> that serve as
convenience wrappers for <code><a href="../reference/sim_apply.html">sim_apply()</a></code> to automate some
common derived quantities of interest. These include</p>
<ul>
<li><p><code><a href="../reference/sim_setx.html">sim_setx()</a></code> – computing predicted values and first
differences at representative or user-specified values of the
predictors</p></li>
<li><p><code><a href="../reference/sim_ame.html">sim_ame()</a></code> – computing average adjusted predictions,
contrasts of average adjusted predictions, and average marginal
effects</p></li>
<li><p><code><a href="../reference/sim_adrf.html">sim_adrf()</a></code> – computing average dose-response
functions and average marginal effects functions</p></li>
</ul>
<p>These are described in their own sections below. In addition, there
are functions that have methods for <code>clarify_est</code> objects,
including <code><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind()</a></code> for combining two
<code>clarify_est</code> objects together and <code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code>
for computing quantities that are derived from the already-computed
derived quantities. These are also described in their own sections
below.</p>
</div>
<div class="section level3">
<h3 id="summarize-and-visualize-the-simulated-distribution">4. Summarize and visualize the simulated distribution<a class="anchor" aria-label="anchor" href="#summarize-and-visualize-the-simulated-distribution"></a>
</h3>
<p>To examine the uncertainty around and perform inference on our
estimated quantities, we can use <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> and
<code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> on the <code>clarify_est</code> object.</p>
<p><code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> displays a density plot of the resulting
estimates across the simulations, with markers identifying the point
estimate (computed using the original model coefficients as recommended
by <span class="citation">Rainey (<a href="#ref-raineyCarefulConsiderationCLARIFY2023">2023</a>)</span>) and,
optionally, uncertainty bounds (which function like confidence or
credible interval bounds). The arguments to <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> are
below:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span>x <span class="op">=</span> , parm <span class="op">=</span> , ci <span class="op">=</span> , level <span class="op">=</span> , method <span class="op">=</span> , reference <span class="op">=</span><span class="op">)</span></span></code></pre></div>
<ul>
<li><p><code>x</code> – the <code>clarify_est</code> object (the output
of a call to <code><a href="../reference/sim_apply.html">sim_apply()</a></code>).</p></li>
<li><p><code>parm</code> – the names or indices of the quantities to be
plotted if more than one was estimated in <code><a href="../reference/sim_apply.html">sim_apply()</a></code>; if
unspecified, all will be plotted.</p></li>
<li><p><code>ci</code> – whether to display lines at the uncertainty
bounds. The default is <code>TRUE</code> to display them.</p></li>
<li><p><code>level</code> – if <code>ci</code> is <code>TRUE</code>, the
desired two-sided confidence level. The default is .95 so that that the
bounds are at the .025 and .975 quantiles when <code>method</code> (see
below) is <code>"quantile"</code>.</p></li>
<li><p><code>method</code> – if <code>ci</code> is <code>TRUE</code>,
the method used to compute the bounds. Allowable methods include the
Normal approximation (<code>"wald"</code>) or using the quantiles of the
resulting distribution (<code>"quantile"</code>). The Normal
approximation involves multiplying the standard deviation of the
estimates (i.e., which functions like the standard error of the sampling
distribution) by the critical Z-statistic computed using
<code>(1-level)/2</code> to create a symmetric margin of error around
the point estimate. The default is <code>"quantile"</code> to instead
use quantile-based bounds.</p></li>
<li><p><code>reference</code> – whether to display a normal density over
the plot for each estimate and an indicator line for the median of the
estimate. The default is <code>FALSE</code> to omit them.</p></li>
</ul>
<p>Below, we plot the first estimate we computed above, the predicted
probability for participant PSID1:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">est1</span>, reference <span class="op">=</span> <span class="cn">TRUE</span>, ci <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p><img src="clarify_files/figure-html/plot1-1.png" alt="A plot of the density of the simulated predicted probability for participant PSID1, overlaid with a Normal distribution and a reference line for the median of the estimates" width="384" style="display: block; margin: auto;"></p>
<p>Overlaid on the plot in red is a Normal distribution with the same
mean and standard deviation as the simulated values; this is requested
by setting <code>reference = TRUE</code>. From the plot, one can see
that the distribution of simulated values is non-Normal, asymmetrical,
and not centered around the estimate, with no values falling above 1
because the outcome is a predicted probability. Given its non-Normality,
the quantile-based bounds may be more appropriate than those resulting
from the Normal approximation, as the bounds computed from the Normal
approximation would be outside the bounds of the estimate. The blue
reference line for the median of the estimates is close to the point
estimate, suggesting it is possible for a monotonic transformation to
have a symmetric distribution around the estimate<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;In fact, we know the inverse link function for the model
(i.e., the Normal distribution function &lt;code&gt;&lt;a href="https://rdrr.io/r/stats/Normal.html" class="external-link"&gt;qnorm()&lt;/a&gt;&lt;/code&gt;) is such a
transformation in this case; &lt;strong&gt;marginaleffects&lt;/strong&gt; and other
packages that implement the delta method for confidence intervals around
model predictions typically automatically compute confidence intervals
on the transformed predictions before transforming the intervals back
using the model’s link function. As long as such a transformation
exists, the quantile intervals will be as valid as those that rely on
transforming and back-transforming.&lt;/p&gt;'><sup>3</sup></a>. The plot itself is a
<code>ggplot</code> object that can be modified using
<code>ggplot2</code> syntax.</p>
<p>We can use <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> to display the value of the point
estimate, the uncertainty bounds, and other statistics that describe the
distribution of estimates. The arguments to <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> are
below:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span>object <span class="op">=</span> , parm <span class="op">=</span> , level <span class="op">=</span> , method <span class="op">=</span> , null <span class="op">=</span> <span class="op">)</span></span></code></pre></div>
<ul>
<li><p><code>object</code> – the <code>clarify_est</code> object (the
output of a call to <code><a href="../reference/sim_apply.html">sim_apply()</a></code>).</p></li>
<li><p><code>parm</code> – the names or indices of the quantities to be
displayed if more than one was estimated in <code><a href="../reference/sim_apply.html">sim_apply()</a></code>; if
unspecified, all will be displayed.</p></li>
<li><p><code>level</code> – the desired two-sided confidence level. The
default is .95 so that that the bounds are at the .025 and .975
quantiles when <code>method</code> (see below) is
<code>"quantile"</code>.</p></li>
<li><p><code>method</code> – the method used to compute the uncertainty
bounds. Allowable methods include a Normal approximation
(<code>"wald"</code>) or using the quantiles of the resulting
distribution (<code>"quantile"</code>). See <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code>
above.</p></li>
<li><p><code>null</code> – an optional argument specifying the desired
null value in a hypothesis test for the estimates. If specified, a
p-value will be computed using either a standard Z-test (if
<code>method</code> is <code>"wald"</code>) or an inversion of the
uncertainty interval (described below). The default is not to display
any p-values.</p></li>
<li><p><code>simultaneous</code> – whether inference (confidence
intervals and p-values) should adjust for multiple comparisons. If
<code>TRUE</code>, the “sup-t” intervals as described by <span class="citation">Hothorn, Bretz, and Westfall (<a href="#ref-hothornSimultaneousInferenceGeneral2008">2008</a>)</span> and
<span class="citation">Montiel Olea and Plagborg-Møller (<a href="#ref-montieloleaSimultaneousConfidenceBands2019">2019</a>)</span>
and their inversion are used. The default is not perform such an
adjustment.</p></li>
</ul>
<p>We can use <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> with the default arguments on our
first <code>clarify_est</code> object to view the point estimate and
quantile-based uncertainty bounds.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est1</span><span class="op">)</span></span>
<span><span class="co">#&gt;       Estimate 2.5 % 97.5 %</span></span>
<span><span class="co">#&gt; PSID1    0.976 0.900  0.997</span></span></code></pre></div>
<p>Our second estimated quantity, the difference between two regression
coefficients, is closer to Normally distributed, as the plot below
demonstrates (and would be expected theoretically), so we will use the
Normal approximation to test the hypothesis that difference differs from
0.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">est2</span>, reference <span class="op">=</span> <span class="cn">TRUE</span>, ci <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p><img src="clarify_files/figure-html/plot2-1.png" alt="A plot of the density of the simulated difference between two regression coefficients, overlaid with a Normal distribution and a reference line for the median of the estimates." width="384" style="display: block; margin: auto;"></p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est2</span>, method <span class="op">=</span> <span class="st">"wald"</span>, null <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#&gt;       Estimate   2.5 %  97.5 % Std. Error Z value P-value</span></span>
<span><span class="co">#&gt; w - h  -0.0996 -0.5150  0.3159     0.2120   -0.47    0.64</span></span></code></pre></div>
<p>The uncertainty intervals and p-values in the <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code>
output are computed using the Normal approximation because we set
<code>method = "wald"</code>, and the p-value for the test that our
estimate is equal to 0 is returned because we set <code>null = 0</code>.
Note that the Normal approximation should be used only when the
simulated posterior distribution is both close to Normal and centered
around the estimate (i.e., when the mean of the simulated values [red
vertical line] coincides with the estimate computed on the original
coefficients [black vertical line]). In such cases, however, the delta
method will likely perform as well, if not better, and all of its other
benefits apply (i.e., it is computationally quicker and not subject to
Monte Carlo error).</p>
</div>
</div>
<div class="section level2">
<h2 id="wrappers-for-sim_apply-sim_setx-sim_ame-and-sim_adrf">Wrappers for <code>sim_apply()</code>: <code>sim_setx()</code>,
<code>sim_ame()</code>, and <code>sim_adrf()</code><a class="anchor" aria-label="anchor" href="#wrappers-for-sim_apply-sim_setx-sim_ame-and-sim_adrf"></a>
</h2>
<p><code><a href="../reference/sim_apply.html">sim_apply()</a></code> can be used to compute the simulated
posterior distribution for an arbitrary derived quantity of interest,
but there are some quantities that are common in applied research and
may otherwise be somewhat challenging to program by hand, so
<strong>clarify</strong> provides shortcut functions to make computing
these quantities simple. These functions include
<code><a href="../reference/sim_setx.html">sim_setx()</a></code>, <code><a href="../reference/sim_ame.html">sim_ame()</a></code>, and
<code><a href="../reference/sim_adrf.html">sim_adrf()</a></code>. Each of these can be used only when regression
models compatible with <strong>clarify</strong> are supplied to the
original call to <code><a href="../reference/sim.html">sim()</a></code>.</p>
<p>Like <code><a href="../reference/sim_apply.html">sim_apply()</a></code>, each of these functions is named
<code>sim_*()</code>, which signifies that they are to be used on an
object produced by <code><a href="../reference/sim.html">sim()</a></code> (i.e., a <code>clarify_sim</code>
object). (Multiple calls to these functions can be applied to the same
<code>clarify_sim</code> object and combined; see the
<code><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind()</a></code> section below.) These functions are described
below.</p>
<div class="section level3">
<h3 id="sim_setx-predictions-at-representative-values">
<code>sim_setx()</code>: predictions at representative values<a class="anchor" aria-label="anchor" href="#sim_setx-predictions-at-representative-values"></a>
</h3>
<p><code><a href="../reference/sim_setx.html">sim_setx()</a></code> provides an interface to compute predictions
at representative and user-supplied values of the predictors. For
example, we might want to know what the effect of treatment is for a
“typical” individual, which corresponds to the contrast between two
model-based predictions (i.e., one under treatment and one under control
for a unit with “typical” covariate values). This functionality mirrors
the <code>setx()</code> and <code>setx1()</code> functionality of
<strong>Zelig</strong> (which is where its name originates) and provides
similar functionality to functions in <strong>modelbased</strong>,
<strong>emmeans</strong>, <strong>effects</strong>, and
<strong>ggeffects</strong>.</p>
<p>For each predictor, the user can specify whether they want
predictions at specific values or at “typical” values, which are defined
in <strong>clarify</strong> as the mode for unordered categorical and
binary variables, the median for ordered categorical variables, and the
mean for continuous variables. Predictions for multiple predictor
combinations can be requested by specifying values that will be used to
create a grid of predictor values, or the grid itself can be supplied as
a data frame of desired predictor profiles. In addition, the “first
difference”, defined here as the difference between predictions for two
predictor combinations, can be computed.</p>
<p>The arguments to <code><a href="../reference/sim_setx.html">sim_setx()</a></code> are as follows:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/sim_setx.html">sim_setx</a></span><span class="op">(</span>sim <span class="op">=</span> , x <span class="op">=</span> , x1 <span class="op">=</span> , outcome <span class="op">=</span> , type <span class="op">=</span> , verbose <span class="op">=</span> , cl <span class="op">=</span> <span class="op">)</span></span></code></pre></div>
<ul>
<li><p><code>sim</code> – a <code>clarify_sim</code> object; the output
of a call to <code><a href="../reference/sim.html">sim()</a></code>.</p></li>
<li><p><code>x</code> – a named list containing the requested values of
the predictors, e.g., <code>list(v1 = 1:4, v2 = "A")</code>, or a data
frame containing the desired profiles. Any predictors not included will
be set at their “typical” value as defined above.</p></li>
<li><p><code>x1</code> – an optional named list or data frame similar to
<code>x</code> except with the value of one predictor changed. When
specified, the first difference is computed between the covariate
combination defined in <code>x</code> (and only one combination is
allowed when <code>x1</code> is specified) and the covariate combination
defined in <code>x1</code>.</p></li>
<li><p><code>outcome</code> – a string containing the name of the
outcome of interest when a multivariate (multiple outcome) model is
supplied to <code><a href="../reference/sim.html">sim()</a></code> or the outcome category of interest when
a multinomial model is supplied to <code><a href="../reference/sim.html">sim()</a></code>. For univariate
(single outcome) and binary outcomes, this is ignored.</p></li>
<li><p><code>type</code> – a string containing the type of predicted
value to return. In most cases, this can be left unspecified to request
predictions on the scale of the outcome.</p></li>
<li><p><code>verbose</code> – whether to display a progress
bar.</p></li>
<li><p><code>cl</code> – an argument that controls parallel processing,
which can be the number of cores to use or a cluster object resulting
from <code><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">parallel::makeCluster()</a></code>.</p></li>
</ul>
<p>Here, we will use <code><a href="../reference/sim_setx.html">sim_setx()</a></code> to examine predicted values
of the outcome for control and treated units, at <code>re75</code> set
to 0 and 20000, and <code>race</code> set to “black”.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_setx.html">sim_setx</a></span><span class="op">(</span><span class="va">s</span>,</span>
<span>                 x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>treat <span class="op">=</span> <span class="fl">0</span><span class="op">:</span><span class="fl">1</span>,</span>
<span>                          re75 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">20000</span><span class="op">)</span>,</span>
<span>                          race <span class="op">=</span> <span class="st">"black"</span><span class="op">)</span>,</span>
<span>                 verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p>When we use <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> on the resulting output, we can
see the estimates and their uncertainty intervals (calculated using
quantiles by default).</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est3</span><span class="op">)</span></span>
<span><span class="co">#&gt;                         Estimate 2.5 % 97.5 %</span></span>
<span><span class="co">#&gt; treat = 0, re75 = 0        0.667 0.548  0.772</span></span>
<span><span class="co">#&gt; treat = 1, re75 = 0        0.712 0.607  0.799</span></span>
<span><span class="co">#&gt; treat = 0, re75 = 20000    0.938 0.726  0.995</span></span>
<span><span class="co">#&gt; treat = 1, re75 = 20000    0.953 0.769  0.996</span></span></code></pre></div>
<p>To see the complete grid of the predictor values used in the
predictions, which helps to identify the “typical” values of the other
predictors, we can access the <code>"setx"</code> attribute of the
object:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/attr.html" class="external-link">attr</a></span><span class="op">(</span><span class="va">est3</span>, <span class="st">"setx"</span><span class="op">)</span></span>
<span><span class="co">#&gt;                         treat married      age     educ  race nodegree     re74</span></span>
<span><span class="co">#&gt; treat = 0, re75 = 0         0       0 27.36319 10.26873 black        1 4557.547</span></span>
<span><span class="co">#&gt; treat = 1, re75 = 0         1       0 27.36319 10.26873 black        1 4557.547</span></span>
<span><span class="co">#&gt; treat = 0, re75 = 20000     0       0 27.36319 10.26873 black        1 4557.547</span></span>
<span><span class="co">#&gt; treat = 1, re75 = 20000     1       0 27.36319 10.26873 black        1 4557.547</span></span>
<span><span class="co">#&gt;                          re75</span></span>
<span><span class="co">#&gt; treat = 0, re75 = 0         0</span></span>
<span><span class="co">#&gt; treat = 1, re75 = 0         0</span></span>
<span><span class="co">#&gt; treat = 0, re75 = 20000 20000</span></span>
<span><span class="co">#&gt; treat = 1, re75 = 20000 20000</span></span></code></pre></div>
<p>We can plot the distributions of the simulated values using
<code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code>, which also separates the predictions by the
predictor values (it is often clearer without the uncertainty bounds).
The <code>var</code> argument controls which variable is used for
faceting the plots.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">est3</span>, var <span class="op">=</span> <span class="st">"re75"</span>, ci <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p><img src="clarify_files/figure-html/plot3-1.png" alt="Two plots of the densities of the simulated predictions of the outcome for control and treated units, one corresponding to re74 = 0 and the other to re75 = 20000." width="480" style="display: block; margin: auto;"></p>
<p>One can see again how a delta method or Normal approximation may have
yielded uncertainty intervals outside the plausible range of the
estimate without applying knowledge of the correct transformation to use
to avoid doing so.</p>
<p>If a continuous variable with many levels is included in the grid of
the predictors, something like a dose-response function for a typical
unit can be generated. Below, we set <code>re75</code> to vary from 0 to
20000 in steps of 2000.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_setx.html">sim_setx</a></span><span class="op">(</span><span class="va">s</span>,</span>
<span>                 x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>treat <span class="op">=</span> <span class="fl">0</span><span class="op">:</span><span class="fl">1</span>,</span>
<span>                          re75 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">20000</span>, by <span class="op">=</span> <span class="fl">2000</span><span class="op">)</span>,</span>
<span>                          race <span class="op">=</span> <span class="st">"black"</span><span class="op">)</span>,</span>
<span>                 verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p>When we plot the output, we can see how the predictions varies across
the levels of <code>re75</code>:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">est4</span><span class="op">)</span></span></code></pre></div>
<p><img src="clarify_files/figure-html/plot4-1.png" alt="A plot of the predicted values of the outcome across levels of re75 from 0 to 20000 with a line for control units and a line for treated units. Each line has an uncertainty band around it." width="480" style="display: block; margin: auto;"></p>
<p>We will return to display average dose-response functions using
<code><a href="../reference/sim_adrf.html">sim_adrf()</a></code> later.</p>
<p>Finally, we can use <code><a href="../reference/sim_setx.html">sim_setx()</a></code> to compute first
differences, the contrast between two covariate combinations. We supply
one covariate profile to <code>x</code> and another to <code>x1</code>,
and <code><a href="../reference/sim_setx.html">sim_setx()</a></code> simulates the two predicted values and their
difference. Below, we simulate first difference for a treated and
control unit who have <code>re75</code> of 0 and typical values of all
other covariates:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est5</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_setx.html">sim_setx</a></span><span class="op">(</span><span class="va">s</span>,</span>
<span>                 x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>treat <span class="op">=</span> <span class="fl">0</span>, re75 <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>,</span>
<span>                 x1 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>treat <span class="op">=</span> <span class="fl">1</span>, re75 <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>,</span>
<span>                 verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p>When we use <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code>, we see the estimates for the
predicted values and their first difference (“FD”):</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est5</span><span class="op">)</span></span>
<span><span class="co">#&gt;           Estimate   2.5 %  97.5 %</span></span>
<span><span class="co">#&gt; treat = 0   0.7856  0.6846  0.8551</span></span>
<span><span class="co">#&gt; treat = 1   0.8213  0.7123  0.9037</span></span>
<span><span class="co">#&gt; FD          0.0357 -0.0517  0.1192</span></span></code></pre></div>
<p>It is possible to compute first differences without using
<code>x1</code> using <code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code>, which we describe
later.</p>
</div>
<div class="section level3">
<h3 id="sim_ame-average-adjusted-predictions-and-average-marginal-effects">
<code>sim_ame()</code>: average adjusted predictions and average
marginal effects<a class="anchor" aria-label="anchor" href="#sim_ame-average-adjusted-predictions-and-average-marginal-effects"></a>
</h3>
<p>Using predicted values and effects at representative values is one
way to summarize regression models, but another way is to compute
average adjusted predictions (AAPs), contrasts of AAPs, and average
marginal effects (AMEs). The definitions for these terms may vary and
the names for these concepts differ across sources, but here we define
AAPs as the average of the predicted values for all units after setting
one predictor to a chosen value, and we define AMEs for binary
predictors as the contrast of two AAPs and for continuous predictors as
the average of instantaneous rate of change in the AAP corresponding to
a small change in the predictor from its observed values across all
units<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;In &lt;strong&gt;marginaleffects&lt;/strong&gt;, AAPs are computed
using &lt;code&gt;avg_predictions()&lt;/code&gt;, AMEs for binary variables are
computed using &lt;code&gt;avg_comparisons()&lt;/code&gt;, and AMEs for continuous
variables are computed using &lt;code&gt;avg_slopes()&lt;/code&gt;. AAPs are
sometimes known as average “counterfactual” predictions.&lt;/p&gt;"><sup>4</sup></a>
<span class="citation">(<a href="#ref-longRegressionModelsCategorical2014">Long and Freese
2014</a>)</span>.</p>
<p>The arguments to <code><a href="../reference/sim_ame.html">sim_ame()</a></code> are as follows:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/sim_ame.html">sim_ame</a></span><span class="op">(</span>sim <span class="op">=</span> , var <span class="op">=</span> , subset <span class="op">=</span> , by <span class="op">=</span> , contrast <span class="op">=</span> , outcome <span class="op">=</span> ,</span>
<span>        type <span class="op">=</span> , eps <span class="op">=</span> , verbose <span class="op">=</span> , cl <span class="op">=</span> <span class="op">)</span></span></code></pre></div>
<ul>
<li><p><code>sim</code> – a <code>clarify_sim</code> object; the output
of a call to <code><a href="../reference/sim.html">sim()</a></code>.</p></li>
<li><p><code>var</code> – the name of focal variable over which to
compute the AAPs or AMEs, or a list containing the values for which AAPs
should be computed.</p></li>
<li><p><code>subset</code> – a logical vector, evaluated in the original
dataset used to fit the model, defining a subset of units for which the
AAPs or AMEs are to be computed.</p></li>
<li><p><code>by</code> – the name of one or more variables for which
AAPs should be computed within subgroups. Can be supplied as a character
vector of variable names or a one-sided formula.</p></li>
<li><p><code>contrast</code> – the name of an effect measure used to
contrast AAPs. For continuous outcomes, <code>"diff"</code> requests the
difference in means, but others are available for binary outcomes,
including <code>"rr"</code> for the risk ratio, <code>"or"</code> for
the odds ratio, and <code>"nnt"</code> for the number needed to treat,
among others. If not specified, only AAPs will be computed if the
variable named in <code>var</code> is categorical or specific values of
the focal variable are specified in <code>var</code>. Ignored when the
variable named in <code>var</code> is continuous and no specific values
are specified because the AME is the only quantity computed. When
<code>var</code> names a multi-category categorical variable,
<code>contrast</code> cannot be used; see the section describing
<code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code> for computing contrasts with them.</p></li>
<li><p><code>outcome</code> – a string containing the name of the
outcome of interest when a multivariate (multiple outcome) model is
supplied to <code><a href="../reference/sim.html">sim()</a></code> or the outcome category of interest when
a multinomial model is supplied to <code><a href="../reference/sim.html">sim()</a></code>. For univariate
(single outcome) and binary outcomes, this is ignored.</p></li>
<li><p><code>type</code> – a string containing the type of predicted
value to return. In most cases, this can be left unspecified to request
predictions on the scale of the outcome (e.g., probabilities for binary
outcomes).</p></li>
<li><p><code>eps</code> – the value by which the observed values of the
variable named in <code>var</code> are changed when it is continuous to
compute the AME. This usually does not need to be specified.</p></li>
<li><p><code>verbose</code> – whether to display a progress
bar.</p></li>
<li><p><code>cl</code> – an argument that controls parallel processing,
which can be the number of cores to use or a cluster object resulting
from <code><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">parallel::makeCluster()</a></code>.</p></li>
</ul>
<p>Here, we will use <code><a href="../reference/sim_ame.html">sim_ame()</a></code> to compute the AME of
<code>treat</code> just among those who were treated (in causal
inference, this is known as the average treatment effect in the treated,
or ATT <span class="citation">(<a href="#ref-greiferChoosingCausalEstimand2023">Greifer and Stuart
2023</a>)</span>). We will request our estimate to be on the risk ratio
scale.</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est6</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_ame.html">sim_ame</a></span><span class="op">(</span><span class="va">s</span>,</span>
<span>                var <span class="op">=</span> <span class="st">"treat"</span>,</span>
<span>                subset <span class="op">=</span> <span class="va">treat</span> <span class="op">==</span> <span class="fl">1</span>,</span>
<span>                contrast <span class="op">=</span> <span class="st">"rr"</span>,</span>
<span>                verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p>We can use <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> to display the estimates and their
uncertainty intervals. Here, we will also use <code>null</code> to
include a test for the null hypothesis that the risk ratio is equal to
1.</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est6</span>, null <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span>`RR` <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;         Estimate 2.5 % 97.5 % P-value</span></span>
<span><span class="co">#&gt; E[Y(0)]    0.687 0.603  0.757       .</span></span>
<span><span class="co">#&gt; E[Y(1)]    0.755 0.689  0.814       .</span></span>
<span><span class="co">#&gt; RR         1.100 0.966  1.276    0.15</span></span></code></pre></div>
<p>Here we see the estimates for the AAPs, <code>E[Y(0)]</code> for the
expected value of the outcome setting <code>treat</code> to 0 and
<code>E[Y(1)]</code> for the expected value of the outcome setting
<code>treat</code> to 1, and the risk ratio <code>RR</code>. The p-value
on the test for the risk ratio aligns with the uncertainty interval
containing 1.</p>
<p>If we instead wanted the risk difference or odds ratio, we would not
have to re-compute the AAPs. Instead, we can use
<code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code> to compute a new derived quantity from the
computed AAPs. The section on <code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code> demonstrates
this.</p>
<p>We can compute the AME for a continuous predictor. Here, we will
consider <code>age</code> (just for demonstration; this analysis does
not have a valid interpretation).</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est7</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_ame.html">sim_ame</a></span><span class="op">(</span><span class="va">s</span>,</span>
<span>                var <span class="op">=</span> <span class="st">"age"</span>,</span>
<span>                verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p>We can use <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> to display the AME estimate and its
uncertainty interval.</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est7</span><span class="op">)</span></span>
<span><span class="co">#&gt;              Estimate    2.5 %   97.5 %</span></span>
<span><span class="co">#&gt; E[dY/d(age)] -0.00605 -0.00933 -0.00222</span></span></code></pre></div>
<p>The AME is named <code>E[dY/d(age)]</code>, which signifies that a
derivative has been computed (more precisely, the average of the
unit-specific derivatives). This estimate can be interpreted like a
slope in a linear regression model, but as a single summary of the
effect of a predictor it is often too coarse to capture nonlinear
relationships. The section below explains how to compute average
dose-response functions for continuous predictors, which provide a more
complete picture of their effects on an outcome.</p>
<p>Below, we will examine effect modification of the ATT by the
predictor <code>married</code> using the <code>by</code> argument to
estimate AAPs and their ratio within levels of <code>married</code>:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est6b</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_ame.html">sim_ame</a></span><span class="op">(</span><span class="va">s</span>,</span>
<span>                 var <span class="op">=</span> <span class="st">"treat"</span>,</span>
<span>                 subset <span class="op">=</span> <span class="va">treat</span> <span class="op">==</span> <span class="fl">1</span>,</span>
<span>                 by <span class="op">=</span> <span class="op">~</span><span class="va">married</span>,</span>
<span>                 contrast <span class="op">=</span> <span class="st">"rr"</span>,</span>
<span>                 verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est6b</span><span class="op">)</span></span>
<span><span class="co">#&gt;           Estimate 2.5 % 97.5 %</span></span>
<span><span class="co">#&gt; E[Y(0)|0]    0.691 0.598  0.764</span></span>
<span><span class="co">#&gt; E[Y(1)|0]    0.733 0.655  0.803</span></span>
<span><span class="co">#&gt; RR[0]        1.061 0.919  1.236</span></span>
<span><span class="co">#&gt; E[Y(0)|1]    0.668 0.547  0.768</span></span>
<span><span class="co">#&gt; E[Y(1)|1]    0.848 0.694  0.942</span></span>
<span><span class="co">#&gt; RR[1]        1.270 0.988  1.593</span></span></code></pre></div>
<p>The presence of effect modification can be tested by testing the
contrast between the effects computed within each level of the
<code>by</code> variable; this demonstrated in the section on
<code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code> below.</p>
</div>
<div class="section level3">
<h3 id="sim_adrf-average-dose-response-functions">
<code>sim_adrf()</code>: average dose-response functions<a class="anchor" aria-label="anchor" href="#sim_adrf-average-dose-response-functions"></a>
</h3>
<p>A dose-response function for an individual is the relationship
between the set value of a continuous focal predictor and the expected
outcome. The average dose-response function (ADRF) is the average of the
dose-response functions across all units. Essentially, it is a function
that relates the value of the predictor to the corresponding AAP of the
outcome, the average value of the outcome were all units to be set to
that level of the predictor. ADRFs can be used to provide additional
detail about the effect of a continuous predictor beyond a single
AME.</p>
<p>A related quantity is the average marginal effect function (AMEF),
which describes the relationship between a continuous focal predictor
and the AME at that level of the predictor. That is, rather than
describing how the outcome changes as a function of the predictor, it
describes how the <em>effect</em> of the predictor on the outcome
changes as a function of the predictor. It is essentially the derivative
of the ADRF and can be used to identify at which points along the ADRF
the predictor has an effect.</p>
<p>The ADRF and AMEF can be computed using <code><a href="../reference/sim_adrf.html">sim_adrf()</a></code>. The
arguments are below:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/sim_adrf.html">sim_adrf</a></span><span class="op">(</span>sim <span class="op">=</span> , var <span class="op">=</span> , subset <span class="op">=</span> , by <span class="op">=</span> , contrast <span class="op">=</span> , at <span class="op">=</span> ,</span>
<span>         n <span class="op">=</span> , outcome <span class="op">=</span> , type <span class="op">=</span> , eps <span class="op">=</span> , verbose <span class="op">=</span> , cl <span class="op">=</span> <span class="op">)</span></span></code></pre></div>
<ul>
<li><p><code>sim</code> – a <code>clarify_sim</code> object; the output
of a call to <code><a href="../reference/sim.html">sim()</a></code>.</p></li>
<li><p><code>var</code> – the name of focal variable over which to
compute the ADRF or AMEF.</p></li>
<li><p><code>subset</code> – a logical vector, evaluated in the original
dataset used to fit the model, defining a subset of units for which the
ARDF or AMEF is to be computed.</p></li>
<li><p><code>by</code> – the name of one or more variables for which the
ADRF or AMEF should be computed within subgroups. Can be supplied as a
character vector of variable names or a one-sided formula.</p></li>
<li><p><code>contrast</code> – either <code>"adrf"</code> or
<code>"amef"</code> to request the ADRF or AMEF, respectively. The
default is to compute the ADRF.</p></li>
<li><p><code>at</code> – the values of the focal predictor at which to
compute the ADRF or AMEF. This should be a vector of values that the
focal predictor can take on. If unspecified, a vector of <code>n</code>
(see below) equally-spaced values from the minimum to the maximum value
of the predictor will be used. This should typically be used only if
quantities are desired over a subset of the values of the focal
predictor.</p></li>
<li><p><code>n</code> – if <code>at</code> is unspecified, the number of
points along the range of the focal predictor at which to compute the
ADRF or AMEF. More yields smoother functions, but will take longer and
require more memory. The default is 21.</p></li>
<li><p><code>outcome</code> – a string containing the name of the
outcome of interest when a multivariate (multiple outcome) model is
supplied to <code><a href="../reference/sim.html">sim()</a></code> or the outcome category of interest when
a multinomial model is supplied to <code><a href="../reference/sim.html">sim()</a></code>. For univariate
(single outcome) and binary outcomes, this is ignored.</p></li>
<li><p><code>type</code> – a string containing the type of predicted
value to return. In most cases, this can be left unspecified to request
predictions on the scale of the outcome.</p></li>
<li><p><code>eps</code> – the value by which the observed values of the
variable named in <code>var</code> are changed when it is continuous to
compute the AMEF. This usually does not need to be specified.</p></li>
<li><p><code>verbose</code> – whether to display a progress
bar.</p></li>
<li><p><code>cl</code> – an argument that controls parallel processing,
which can be the number of cores to use or a cluster object resulting
from <code><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">parallel::makeCluster()</a></code>.</p></li>
</ul>
<p>Here, we will consider <code>age</code> (just for demonstration; this
analysis does not have a valid interpretation) and compute the ADRF and
AMEF of <code>age</code> on the outcome. We will only examine ages
between 18 and 50, even though the range of <code>age</code> goes
slightly beyond these values. First, we will compute the ADRF of
<code>age</code>, which examines how the outcome would vary on average
if one set all unit’s value of <code>age</code> to each value between 18
and 50 (here we only use even ages to speed up computation).</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">age_seq</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">18</span>, <span class="fl">50</span>, by <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="va">est8</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_adrf.html">sim_adrf</a></span><span class="op">(</span><span class="va">s</span>,</span>
<span>                 var <span class="op">=</span> <span class="st">"age"</span>,</span>
<span>                 contrast <span class="op">=</span> <span class="st">"adrf"</span>,</span>
<span>                 at <span class="op">=</span> <span class="va">age_seq</span>,</span>
<span>                 verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p>We can plot the ADRF using <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code>; here we set
<code>simultaneous = TRUE</code> to request simultaneous confidence
bands.</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">est8</span>, simultaneous <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="clarify_files/figure-html/plot8-1.png" alt="A plot of the average dose-response function for the outcome against age. The line has an uncertainty band around it." width="480" style="display: block; margin: auto;"></p>
<p>From the plot, we can see that as <code>age</code> increases, the
expected outcome decreases.</p>
<p>We can also examine the AAPs at the requested ages using
<code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code>, which will display all the estimated AAPs by
default, so we will request just the first 4 (<code>age</code>s 18 to
24):</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est8</span>, parm <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span></span>
<span><span class="co">#&gt;          Estimate 2.5 % 97.5 %</span></span>
<span><span class="co">#&gt; E[Y(18)]    0.821 0.768  0.855</span></span>
<span><span class="co">#&gt; E[Y(20)]    0.811 0.763  0.843</span></span>
<span><span class="co">#&gt; E[Y(22)]    0.800 0.756  0.830</span></span>
<span><span class="co">#&gt; E[Y(24)]    0.788 0.748  0.817</span></span></code></pre></div>
<p>Next we will compute the AMEF, the effect of <code>age</code> at each
level of <code>age</code>.</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est9</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_adrf.html">sim_adrf</a></span><span class="op">(</span><span class="va">s</span>,</span>
<span>                 var <span class="op">=</span> <span class="st">"age"</span>,</span>
<span>                 contrast <span class="op">=</span> <span class="st">"amef"</span>,</span>
<span>                 at <span class="op">=</span> <span class="va">age_seq</span>,</span>
<span>                 verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p>We can plot the AMEF using <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code>:</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">est9</span>, simultaneous <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="clarify_files/figure-html/plot9-1.png" alt="A plot of the average marginal effect function for the outcome against age. The line has an uncertainty band around it." width="480" style="display: block; margin: auto;"></p>
<p>From the plot, we can see the AME of <code>age</code> decreases
slightly but is mostly constant across values of <code>age</code>, and
the uncertainty intervals for the AMEs consistently exclude 0.</p>
</div>
</div>
<div class="section level2">
<h2 id="transforming-and-combining-estimates">Transforming and combining estimates<a class="anchor" aria-label="anchor" href="#transforming-and-combining-estimates"></a>
</h2>
<p>Often, our quantities of interest are not just the outputs of the
functions above, but comparisons between them. For example, to test for
moderation of a treatment effect, we may want to compare AMEs in
multiple groups defined by the moderator. Or, it might be that we are
interested in an effect described using a different effect measure than
the one originally produced; for example, we may decide we want the risk
difference AME after computing the risk ratio AME. The functions
<code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code> and <code><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind()</a></code> allow users to
transform quantities in a single <code>clarify_est</code> object and
combine two <code>clarify_est</code> objects. These are essential for
computing quantities that themselves are derived from the derived
quantities computed by the <code>sim_*()</code> functions.</p>
<div class="section level3">
<h3 id="transform">
<code>transform()</code><a class="anchor" aria-label="anchor" href="#transform"></a>
</h3>
<p><code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code> is a generic function in R that is typically
used to create a new variable in a data frame that is a function of
other columns. For example, to compute the binary outcome we used in our
model, we could have run the following<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;Users familiar with the &lt;code&gt;tidyverse&lt;/code&gt; will note
the similarities between &lt;code&gt;&lt;a href="https://rdrr.io/r/base/transform.html" class="external-link"&gt;transform()&lt;/a&gt;&lt;/code&gt; and
&lt;code&gt;&lt;a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link"&gt;dplyr::mutate()&lt;/a&gt;&lt;/code&gt;; only &lt;code&gt;&lt;a href="https://rdrr.io/r/base/transform.html" class="external-link"&gt;transform()&lt;/a&gt;&lt;/code&gt; can be used
with &lt;code&gt;clarify_est&lt;/code&gt; objects.&lt;/p&gt;'><sup>5</sup></a>:</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lalonde</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform</a></span><span class="op">(</span><span class="va">lalonde</span>,</span>
<span>                     re78_0 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html" class="external-link">ifelse</a></span><span class="op">(</span><span class="va">re78</span> <span class="op">==</span> <span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Similarly, to compute a derived or transformed quantity from a
<code>clarify_est</code> object, we can use <code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code>.
Here, we will compute the risk difference AME of <code>treat</code>;
previously, we used <code><a href="../reference/sim_ame.html">sim_ame()</a></code> to compute the AAPs and the
risk ratio.</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est6</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform</a></span><span class="op">(</span><span class="va">est6</span>,</span>
<span>                  RD <span class="op">=</span> <span class="va">`E[Y(1)]`</span> <span class="op">-</span> <span class="va">`E[Y(0)]`</span><span class="op">)</span></span></code></pre></div>
<p>Note that we used tics (<code>`</code>) around the names of the AAPs;
this is necessary when they contain special characters like parentheses
or brackets. An alternative is to use the shortcut names
<code>.b#</code>, where <code>#</code> is replaced with a number (e.g.,
as <code>.b1</code>, <code>.b2</code>, etc.) corresponding to the index
of the quantity referenced. For example, because
<code>E[Y(1)]</code>and<code>E[Y(0)]</code> are the second and first
computed quantities, respectively, the above code could be replaced
with</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est6</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform</a></span><span class="op">(</span><span class="va">est6</span>,</span>
<span>                  RD <span class="op">=</span> <span class="va">.b2</span> <span class="op">-</span> <span class="va">.b1</span><span class="op">)</span></span></code></pre></div>
<p>which will yield identical results<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;Note that if a quantity is named &lt;code&gt;.b#&lt;/code&gt;, e.g.,
&lt;code&gt;.b1&lt;/code&gt;, it can only be referred to using the positional
shortcut and not its named. That is, the positional shortcut takes
precedence over the names of the quantities.&lt;/p&gt;"><sup>6</sup></a>.</p>
<p>When we run <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> on the output, the new quantity,
which we named “RD”, will be displayed along with the other estimates.
We will also set a null value for this quantity.</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est6</span>, null <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span>`RR` <span class="op">=</span> <span class="fl">1</span>, `RD` <span class="op">=</span> <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;         Estimate   2.5 %  97.5 % P-value</span></span>
<span><span class="co">#&gt; E[Y(0)]   0.6866  0.6029  0.7572       .</span></span>
<span><span class="co">#&gt; E[Y(1)]   0.7551  0.6887  0.8136       .</span></span>
<span><span class="co">#&gt; RR        1.0998  0.9657  1.2760    0.15</span></span>
<span><span class="co">#&gt; RD        0.0685 -0.0263  0.1656    0.15</span></span></code></pre></div>
<p>As mentioned previously, one benefit of using simulation-based
inference with p-values computed from inverting the confidence intervals
is that the p-values for testing the same hypothesis with the risk
difference and risk ratio (and any other effect measure for comparing a
pair of values) will always exactly align, thereby ensuring inference
does not depend on the effect measure used. In contrast, Wald-type
inference (based on either the simulation-derived or delta method
standard error) is not invariant to transformations of the quantity of
interest.</p>
<p>The same value would be computed if we were to have called
<code><a href="../reference/sim_ame.html">sim_ame()</a></code> on the same <code>clarify_sim</code> object and
requested the risk difference using <code>contrast = "diff"</code>;
using <code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code> saves time because the AAPs are already
computed and stored in the <code>clarify_est</code> object.</p>
<p>We can use <code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code> along with the <code>by</code>
variable in <code><a href="../reference/sim_ame.html">sim_ame()</a></code> to compute the contrast between
quantities computed within each subgroup of <code>married</code>.
Previously we used <code>by</code> to compute the risk ratio ATT within
levels of <code>married</code>; here we will compute the ratio of these
risk ratios to assess the presence of effect modification.</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est6b</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform</a></span><span class="op">(</span>`RR[1]/RR[0]` <span class="op">=</span> <span class="va">`RR[1]`</span> <span class="op">/</span> <span class="va">`RR[0]`</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span>parm <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"RR[0]"</span>, <span class="st">"RR[1]"</span>, <span class="st">"RR[1]/RR[0]"</span><span class="op">)</span>,</span>
<span>          null <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt;             Estimate 2.5 % 97.5 % P-value  </span></span>
<span><span class="co">#&gt; RR[0]          1.061 0.919  1.236    0.43  </span></span>
<span><span class="co">#&gt; RR[1]          1.270 0.988  1.593    0.07 .</span></span>
<span><span class="co">#&gt; RR[1]/RR[0]    1.196 0.905  1.506    0.18  </span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span></code></pre></div>
<p><code>RR[1]/RR[0]</code> contains the ratio of the risk ratios for
<code>married = 1</code> and <code>married = 0</code>. Here we also
include a test for whether each of the risk ratios and their ratio
differ from 1, which is equivalent to testing whether the risk ratios
differ across levels of <code>married</code>.</p>
</div>
<div class="section level3">
<h3 id="cbind">
<code>cbind()</code><a class="anchor" aria-label="anchor" href="#cbind"></a>
</h3>
<p><code><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind()</a></code> is another generic R function that is typically
used to combine two or more datasets columnwise (i.e., to widen a
dataset). In <strong>clarify</strong>, <code><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind()</a></code> can be used
to combine two <code>clarify_est</code> objects so that the estimates
can be examined jointly and so that it is possible to compare them
directly. For example, if we were to compute AMEs in two subgroups using
<code>subset</code> and wanted to compare them, we would call
<code><a href="../reference/sim_ame.html">sim_ame()</a></code> twice, one for each subset (though in practice it
is more effective to use <code>by</code>; this is just for
illustration), as demonstrated below:</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># AME of treat with race = "black"</span></span>
<span><span class="va">est10b</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_ame.html">sim_ame</a></span><span class="op">(</span><span class="va">s</span>, var <span class="op">=</span> <span class="st">"treat"</span>, subset <span class="op">=</span> <span class="va">race</span> <span class="op">==</span> <span class="st">"black"</span>,</span>
<span>                  contrast <span class="op">=</span> <span class="st">"diff"</span>, verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est10b</span><span class="op">)</span></span>
<span><span class="co">#&gt;         Estimate   2.5 %  97.5 %</span></span>
<span><span class="co">#&gt; E[Y(0)]   0.6677  0.5715  0.7484</span></span>
<span><span class="co">#&gt; E[Y(1)]   0.7439  0.6714  0.8058</span></span>
<span><span class="co">#&gt; Diff      0.0762 -0.0209  0.1768</span></span>
<span></span>
<span><span class="co"># AME of treat with race = "hispan"</span></span>
<span><span class="va">est10h</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_ame.html">sim_ame</a></span><span class="op">(</span><span class="va">s</span>, var <span class="op">=</span> <span class="st">"treat"</span>, subset <span class="op">=</span> <span class="va">race</span> <span class="op">==</span> <span class="st">"hispan"</span>,</span>
<span>                  contrast <span class="op">=</span> <span class="st">"diff"</span>, verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est10h</span><span class="op">)</span></span>
<span><span class="co">#&gt;         Estimate    2.5 %   97.5 %</span></span>
<span><span class="co">#&gt; E[Y(0)]  0.82664  0.71804  0.89555</span></span>
<span><span class="co">#&gt; E[Y(1)]  0.89707  0.79463  0.95146</span></span>
<span><span class="co">#&gt; Diff     0.07044 -0.00533  0.14530</span></span></code></pre></div>
<p>Here, we computed the risk difference for the subgroups
<code>race = "black"</code> and <code>race = "hispan"</code>. If we
wanted to compare the risk differences, we could combine them and
compute a new quantity equal to their difference. We will do that
below.</p>
<p>First, we need to rename the quantities in each object so they do not
overlap; we can do so using <code><a href="https://rdrr.io/r/base/names.html" class="external-link">names()</a></code>, which has a special
method for <code>clarify_est</code> objects.</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">est10b</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">est10b</span><span class="op">)</span>, <span class="st">"b"</span>, sep <span class="op">=</span> <span class="st">"_"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">est10h</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">est10h</span><span class="op">)</span>, <span class="st">"h"</span>, sep <span class="op">=</span> <span class="st">"_"</span><span class="op">)</span></span></code></pre></div>
<p>Next, we use <code><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind()</a></code> to bind the objects together.</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est10</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">est10b</span>, <span class="va">est10h</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est10</span><span class="op">)</span></span>
<span><span class="co">#&gt;           Estimate    2.5 %   97.5 %</span></span>
<span><span class="co">#&gt; E[Y(0)]_b  0.66770  0.57151  0.74836</span></span>
<span><span class="co">#&gt; E[Y(1)]_b  0.74389  0.67143  0.80581</span></span>
<span><span class="co">#&gt; Diff_b     0.07619 -0.02086  0.17679</span></span>
<span><span class="co">#&gt; E[Y(0)]_h  0.82664  0.71804  0.89555</span></span>
<span><span class="co">#&gt; E[Y(1)]_h  0.89707  0.79463  0.95146</span></span>
<span><span class="co">#&gt; Diff_h     0.07044 -0.00533  0.14530</span></span></code></pre></div>
<p>Finally, we can use <code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code> to compute the
difference between the risk differences:</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est10</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform</a></span><span class="op">(</span><span class="va">est10</span>,</span>
<span>                   `Dh - Db` <span class="op">=</span> <span class="va">Diff_h</span> <span class="op">-</span> <span class="va">Diff_b</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est10</span>, parm <span class="op">=</span> <span class="st">"Dh - Db"</span><span class="op">)</span></span>
<span><span class="co">#&gt;         Estimate    2.5 %   97.5 %</span></span>
<span><span class="co">#&gt; Dh - Db -0.00575 -0.06782  0.04043</span></span></code></pre></div>
<p>Importantly, <code><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind()</a></code> can only be used to join together
<code>clarify_est</code> objects computed using the same simulated
coefficients (i.e., resulting from the same call to <code><a href="../reference/sim.html">sim()</a></code>).
This preserves the covariance among the estimated quantities, which is
critical for maintaining valid inference. That is, <code><a href="../reference/sim.html">sim()</a></code>
should only be called once per model, and all derived quantities should
be computed using its output.</p>
</div>
</div>
<div class="section level2">
<h2 id="using-clarify-with-multiply-imputed-data">Using <strong>clarify</strong> with multiply imputed data<a class="anchor" aria-label="anchor" href="#using-clarify-with-multiply-imputed-data"></a>
</h2>
<p>Multiple imputation is a popular method of estimating quantities of
interest in the presence of missing data and involves creating multiple
versions of the original dataset each with the missing values imputed
with estimates from an imputation model. Simulation-based inference in
multiply imputed data is relatively straightforward. Simulated
coefficients are drawn from the model estimated in each imputed dataset
separately, and then the simulated coefficients are pooled into a single
set of simulated coefficients. In Bayesian terms, this would be
considered “mixing draws” and is the recommended approach for Bayesian
analysis with multiply imputed data <span class="citation">(<a href="#ref-zhouNoteBayesianInference2010">Zhou and Reiter
2010</a>)</span>.</p>
<p>Using <strong>clarify</strong> with multiply imputed data is simple.
Rather than using <code><a href="../reference/sim.html">sim()</a></code>, we use the function
<code><a href="../reference/misim.html">misim()</a></code>. <code><a href="../reference/misim.html">misim()</a></code> functions just like
<code><a href="../reference/sim.html">sim()</a></code> except that it takes in a list of model fits (i.e.,
containing a model fit to each imputed dataset) or an object containing
such a list (e.g., a <code>mira</code> object from
<code><a href="https://amices.org/mice/reference/with.mids.html" class="external-link">mice::with()</a></code> or a <code>mimira</code> object from
<code>MatchThem::with()</code>). <code><a href="../reference/misim.html">misim()</a></code> simulates
coefficient distributions within each imputed dataset and then appends
them together to a form a single combined set of coefficient draws.</p>
<p><code><a href="../reference/sim_apply.html">sim_apply()</a></code> and its wrappers accept the output of
<code><a href="../reference/misim.html">misim()</a></code> and compute the desired quantity using each set of
coefficients. When these functions rely on using a dataset (e.g.,
<code><a href="../reference/sim_ame.html">sim_ame()</a></code>, which averages predicted outcomes across all
units in the dataset used to fit the model), they automatically know to
associate a given coefficient draw with the imputed dataset that was
used to fit the model that produced that draw. In user-written functions
supplied to the <code>FUN</code> argument of <code><a href="../reference/sim_apply.html">sim_apply()</a></code>,
it is important to correctly extract the dataset from the model fit.
This is demonstrated below.</p>
<p>The final estimates of the quantity of interest is computed as the
mean of the estimates computed in each imputed dataset (i.e., using the
original coefficients, not the simulated ones), which is the same
quantity that would be computed using standard pooling rules. This is
not always valid for noncollapsible estimates, like ratios, and so care
should be taken to ensure the mean of the resulting estimates has a
valid interpretation (this is related to the transformation-induced bias
described by <span class="citation">Rainey (<a href="#ref-rainey2017">2017</a>)</span>).</p>
<p>The arguments to <code><a href="../reference/misim.html">misim()</a></code> are as follows:</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/misim.html">misim</a></span><span class="op">(</span>fitlist <span class="op">=</span> , n <span class="op">=</span> , vcov <span class="op">=</span> , coefs <span class="op">=</span> , dist <span class="op">=</span> <span class="op">)</span></span></code></pre></div>
<ul>
<li><p><code>fitlist</code> – a list of model fits or an accepted object
containing them (e.g., a <code>mira</code> object from
<code><a href="https://amices.org/mice/reference/with.mids.html" class="external-link">mice::with()</a></code>)</p></li>
<li><p><code>n</code> – the number of simulations to run <em>for each
imputed dataset</em>. The default is 1000, but fewer can be used because
the total number of simulated quantities will be <code>m * n</code>,
where <code>m</code> is the number of imputed datasets.</p></li>
<li><p><code>vcov</code>, <code>coefs</code>, <code>dist</code> – the
same as with <code><a href="../reference/sim.html">sim()</a></code>, except that a list of such arguments
can be supplied to be applied to each imputed dataset.</p></li>
</ul>
<p>Below we illustrate using <code><a href="../reference/misim.html">misim()</a></code> and
<code><a href="../reference/sim_apply.html">sim_apply()</a></code> with multiply imputed data. We will use the
<code>africa</code> dataset from the <strong>Amelia</strong>
package.</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://gking.harvard.edu/amelia" class="external-link">Amelia</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"africa"</span>, package <span class="op">=</span> <span class="st">"Amelia"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Multiple imputation</span></span>
<span><span class="va">a.out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/Amelia/man/amelia.html" class="external-link">amelia</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">africa</span>, m <span class="op">=</span> <span class="fl">10</span>, cs <span class="op">=</span> <span class="st">"country"</span>,</span>
<span>                ts <span class="op">=</span> <span class="st">"year"</span>, logs <span class="op">=</span> <span class="st">"gdp_pc"</span>, p2s <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Fit model to each dataset</span></span>
<span><span class="va">model.list</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/with.html" class="external-link">with</a></span><span class="op">(</span><span class="va">a.out</span>, <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">gdp_pc</span> <span class="op">~</span> <span class="va">infl</span> <span class="op">*</span> <span class="va">trade</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Simulate coefficients, 100 draws per imputation</span></span>
<span><span class="va">si</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/misim.html">misim</a></span><span class="op">(</span><span class="va">model.list</span>, n <span class="op">=</span> <span class="fl">100</span><span class="op">)</span></span>
<span></span>
<span><span class="va">si</span></span>
<span><span class="co">#&gt; A `clarify_misim` object</span></span>
<span><span class="co">#&gt;  - 4 coefficients, 10 imputations with 100 simulated values each</span></span>
<span><span class="co">#&gt;  - sampled distributions: multivariate t(116)</span></span></code></pre></div>
<p>The function we will be applying to each imputed dataset will be one
that computes the AME of <code>infl</code>. (We will run the same
analysis afterward using <code><a href="../reference/sim_ame.html">sim_ame()</a></code>.)</p>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sim_fun</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">fit</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co">#Extract the original dataset using get_predictors()</span></span>
<span>  <span class="va">X</span> <span class="op">&lt;-</span> <span class="fu">insight</span><span class="fu">::</span><span class="fu"><a href="https://easystats.github.io/insight/reference/get_predictors.html" class="external-link">get_predictors</a></span><span class="op">(</span><span class="va">fit</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">p0</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fit</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#Predictions after perturbing infl slightly</span></span>
<span>  <span class="va">p1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fit</span>, newdata <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform</a></span><span class="op">(</span><span class="va">X</span>, infl <span class="op">=</span> <span class="va">infl</span> <span class="op">+</span> <span class="fl">1e-5</span><span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span>AME <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="op">(</span><span class="va">p1</span> <span class="op">-</span> <span class="va">p0</span><span class="op">)</span> <span class="op">/</span> <span class="fl">1e-5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">est_mi</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_apply.html">sim_apply</a></span><span class="op">(</span><span class="va">si</span>, FUN <span class="op">=</span> <span class="va">sim_fun</span>, verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est_mi</span><span class="op">)</span></span>
<span><span class="co">#&gt;     Estimate 2.5 % 97.5 %</span></span>
<span><span class="co">#&gt; AME    -5.76 -9.39  -2.38</span></span></code></pre></div>
<p>Note that <code><a href="../reference/sim_apply.html">sim_apply()</a></code> “knows” which imputation produced
each set of simulated coefficients, so using
<code><a href="https://easystats.github.io/insight/reference/get_predictors.html" class="external-link">insight::get_predictors()</a></code> on the <code>fit</code> supplied
to <code>sim_fun()</code> will use the right dataset. Care should be
taken when analyses restrict each imputed dataset in a different way
(e.g. when matching with a caliper in each one), as the resulting
imputations may not refer to a specific target population and mixing the
draws may be invalid.</p>
<p>Below, we can use <code><a href="../reference/sim_ame.html">sim_ame()</a></code>:</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">est_mi2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_ame.html">sim_ame</a></span><span class="op">(</span><span class="va">si</span>, var <span class="op">=</span> <span class="st">"infl"</span>, verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est_mi2</span><span class="op">)</span></span>
<span><span class="co">#&gt;               Estimate 2.5 % 97.5 %</span></span>
<span><span class="co">#&gt; E[dY/d(infl)]    -5.76 -9.39  -2.38</span></span></code></pre></div>
<p>We get the same results, as expected.</p>
<p>Note that <code><a href="../reference/misim.html">misim()</a></code> is compatible with model fit objects
from <strong>mice</strong>, <strong>Amelia</strong>,
<strong>MatchThem</strong>, and any other package that produces a list
of model fit objects with each corresponding to the output of a model
fit to an imputed dataset.</p>
</div>
<div class="section level2">
<h2 id="comparison-to-other-packages">Comparison to other packages<a class="anchor" aria-label="anchor" href="#comparison-to-other-packages"></a>
</h2>
<p>Several packages offer methods for computing interpretable quantities
form regression models, including <strong>emmeans</strong> <span class="citation">(<a href="#ref-emmeans2024">Lenth 2024</a>)</span>,
<strong>margins</strong> <span class="citation">(<a href="#ref-margins2021">Leeper 2024</a>)</span>,
<strong>modelbased</strong> <span class="citation">(<a href="#ref-modelbased2020">Makowski et al. 2020</a>)</span>, and
<strong>marginaleffects</strong> <span class="citation">(<a href="#ref-marginaleffectsforthcoming">Arel-Bundock, Greifer, and Heiss
2024</a>)</span>. Many of the quantities computed by these packages can
also be computed by <strong>clarify</strong>, the primary difference
being that <strong>clarify</strong> uses simulation-based inference
rather than delta method-based inference.</p>
<p><strong>marginaleffects</strong> offers the most similar
functionality to <strong>clarify</strong>, and <strong>clarify</strong>
depends on functionality provided by <strong>marginaleffects</strong> to
accommodate a wide variety of regression models.
<strong>marginaleffects</strong> also offers simulation-based inference
using <code><a href="https://marginaleffects.com/man/r/inferences.html" class="external-link">marginaleffects::inferences()</a></code> and support for
arbitrary user-specified post-estimation functions using
<code><a href="https://marginaleffects.com/man/r/hypotheses.html" class="external-link">marginaleffects::hypotheses()</a></code>. However,
<strong>clarify</strong> and <code>marignalefefcts</code> differ in
several ways. The largest difference is that <strong>clarify</strong>
supports iterative building of more and more complex hypotheses through
the <code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code> method, which quickly computes new
quantities and transformation from the existing computed quantities,
whereas <strong>marginaleffects</strong> only supports a single
transformation and, as of version 0.20.0, cannot use simulation-based
inference for these quantities.</p>
<p>Because of <strong>clarify</strong>’s focus on simulation, it
provides functionality directly aimed at improving simulation-based
inference, including plots to view the distributions of simulated values
and support for parallel processing. <strong>clarify</strong> also
provides support for simulation-based inference of multiply imputed
data, which does not require any special pooling rules.</p>
<p>There are areas and cases where <strong>marginaleffects</strong> may
be the better choice than <strong>clarify</strong> or where the
differences between the packages are of little consequence.
<strong>marginaleffects</strong> focuses on providing a complete
framework for post-estimation using model predictions, whereas
<strong>clarify</strong> is primarily focused on supporting user-defined
functions, with commonly used estimators offered as a convenience. In
cases where the delta method is an acceptable approximation (e.g., for
quantities computed from linear models or other quantities known to be
approximately Normally distributed in finite samples), using the delta
method through <strong>marginaleffects</strong> will be much faster,
more accurate, and more replicable than the simulation-based inference
<strong>clarify</strong> provides. For the quantities easily computed by
<strong>marginaleffects</strong> that support simulation-based inference
through <code><a href="https://marginaleffects.com/man/r/inferences.html" class="external-link">marginaleffects::inferences()</a></code>, using
<strong>marginaleffects</strong> can provide a more familiar and
flexible syntax than <strong>clarify</strong> might offer. Ultimately,
the user should use the package that supports their desired syntax and
mode of inference.</p>
</div>
<div class="section level2">
<h2 id="conclusion">Conclusion<a class="anchor" aria-label="anchor" href="#conclusion"></a>
</h2>
<p><strong>clarify</strong> provides functionality to facilitate
simulation-based inference of deriving quantities from regression
models. This framework provides an alternative to the delta method that
can yield confidence intervals with closer to nominal coverage for some
quantities of interest. While we do not claim simulation-based inference
should be universally preferred over delta method-based inference, there
are cases in which it can retain some advantageous properties, and we
hope the availability of these methods in <strong>clarify</strong>
encourages additional research on when those properties can be realized
and facilitates empirical work that takes advantages of these
properties.</p>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-marginaleffectsforthcoming" class="csl-entry">
Arel-Bundock, Vincent, Noah Greifer, and Andrew Heiss. 2024. <span>“How
to <span>Interpret Statistical Models Using</span> Marginaleffects for
<span>R</span> and <span>Python</span>.”</span> <em>Journal of
Statistical Software</em> 111: 1–32. <a href="https://doi.org/10.18637/jss.v111.i09" class="external-link">https://doi.org/10.18637/jss.v111.i09</a>.
</div>
<div id="ref-dehejiaCausalEffectsNonexperimental1999" class="csl-entry">
Dehejia, Rajeev H., and Sadek Wahba. 1999. <span>“Causal Effects in
Nonexperimental Studies: Reevaluating the Evaluation of Training
Programs.”</span> <em>Journal of the American Statistical
Association</em> 94 (448): 1053–62. <a href="https://doi.org/10.1080/01621459.1999.10473858" class="external-link">https://doi.org/10.1080/01621459.1999.10473858</a>.
</div>
<div id="ref-efronBootstrapMethodsStandard1986" class="csl-entry">
Efron, B., and R. Tibshirani. 1986. <span>“Bootstrap Methods for
Standard Errors, Confidence Intervals, and Other Measures of Statistical
Accuracy.”</span> <em>Statistical Science</em> 1 (1): 54–75. <a href="https://www.jstor.org/stable/2245500" class="external-link">https://www.jstor.org/stable/2245500</a>.
</div>
<div id="ref-greiferChoosingCausalEstimand2023" class="csl-entry">
Greifer, Noah, and Elizabeth A. Stuart. 2023. <span>“Choosing the Causal
Estimand for Propensity Score Analysis of Observational Studies.”</span>
<a href="https://doi.org/10.48550/arXiv.2106.10577" class="external-link">https://doi.org/10.48550/arXiv.2106.10577</a>.
</div>
<div id="ref-herronPostestimationUncertaintyLimited1999" class="csl-entry">
Herron, Michael C. 1999. <span>“Postestimation Uncertainty in Limited
Dependent Variable Models.”</span> <em>Political Analysis</em> 8 (1):
83–98. <a href="https://doi.org/10.1093/oxfordjournals.pan.a029806" class="external-link">https://doi.org/10.1093/oxfordjournals.pan.a029806</a>.
</div>
<div id="ref-JSSv042i08" class="csl-entry">
Ho, Daniel E., Kosuke Imai, Gary King, and Elizabeth A. Stuart. 2011.
<span>“MatchIt: Nonparametric Preprocessing for Parametric Causal
Inference.”</span> <em>Journal of Statistical Software, Articles</em> 42
(8): 1–28. <a href="https://doi.org/10.18637/jss.v042.i08" class="external-link">https://doi.org/10.18637/jss.v042.i08</a>.
</div>
<div id="ref-holeComparisonApproachesEstimating2007" class="csl-entry">
Hole, Arne Risa. 2007. <span>“A Comparison of Approaches to Estimating
Confidence Intervals for Willingness to Pay Measures.”</span> <em>Health
Economics</em> 16 (8): 827–40. <a href="https://doi.org/10.1002/hec.1197" class="external-link">https://doi.org/10.1002/hec.1197</a>.
</div>
<div id="ref-hothornSimultaneousInferenceGeneral2008" class="csl-entry">
Hothorn, Torsten, Frank Bretz, and Peter Westfall. 2008.
<span>“Simultaneous Inference in General Parametric Models.”</span>
<em>Biometrical Journal</em> 50 (3): 346–63. <a href="https://doi.org/10.1002/bimj.200810425" class="external-link">https://doi.org/10.1002/bimj.200810425</a>.
</div>
<div id="ref-imaiCommonFrameworkStatistical2008a" class="csl-entry">
Imai, Kosuke, Gary King, and Olivia Lau. 2008. <span>“Toward a Common
Framework for Statistical Analysis and Development.”</span> <em>Journal
of Computational and Graphical Statistics</em> 17 (4): 892–913. <a href="https://doi.org/10.1198/106186008X384898" class="external-link">https://doi.org/10.1198/106186008X384898</a>.
</div>
<div id="ref-kingMakingMostStatistical2000" class="csl-entry">
King, Gary, Michael Tomz, and Jason Wittenberg. 2000. <span>“Making the
Most of Statistical Analyses: Improving Interpretation and
Presentation.”</span> <em>American Journal of Political Science</em> 44
(2): 347–61. <a href="https://doi.org/10.2307/2669316" class="external-link">https://doi.org/10.2307/2669316</a>.
</div>
<div id="ref-krinsky1986" class="csl-entry">
Krinsky, Itzhak, and A. Leslie Robb. 1986. <span>“On Approximating the
Statistical Properties of Elasticities.”</span> <em>The Review of
Economics and Statistics</em> 68 (4): 715. <a href="https://doi.org/10.2307/1924536" class="external-link">https://doi.org/10.2307/1924536</a>.
</div>
<div id="ref-margins2021" class="csl-entry">
Leeper, Thomas J. 2024. <em>Margins: Marginal Effects for Model
Objects</em>. <a href="https://doi.org/10.32614/CRAN.package.margins" class="external-link">https://doi.org/10.32614/CRAN.package.margins</a>.
</div>
<div id="ref-emmeans2024" class="csl-entry">
Lenth, Russell V. 2024. <em>Emmeans: Estimated Marginal Means, Aka
Least-Squares Means</em>. <a href="https://doi.org/10.32614/CRAN.package.emmeans" class="external-link">https://doi.org/10.32614/CRAN.package.emmeans</a>.
</div>
<div id="ref-longRegressionModelsCategorical2014" class="csl-entry">
Long, J. Scott, and Jeremy Freese. 2014. <em>Regression Models for
Categorical Dependent Variables Using Stata</em>. Third edition. College
Station, Texas: Stata Press Publication, StataCorp LP.
</div>
<div id="ref-mackinnonConfidenceLimitsIndirect2004" class="csl-entry">
MacKinnon, David P., Chondra M. Lockwood, and Jason Williams. 2004.
<span>“Confidence Limits for the Indirect Effect: Distribution of the
Product and Resampling Methods.”</span> <em>Multivariate Behavioral
Research</em> 39 (1): 99–128. <a href="https://doi.org/10.1207/s15327906mbr3901_4" class="external-link">https://doi.org/10.1207/s15327906mbr3901_4</a>.
</div>
<div id="ref-modelbased2020" class="csl-entry">
Makowski, Dominique, Mattan S. Ben-Shachar, Indrajeet Patil, and Daniel
Lüdecke. 2020. <span>“Estimation of Model-Based Predictions, Contrasts
and Means.”</span> <em>CRAN</em>. <a href="https://doi.org/10.32614/CRAN.package.modelbased" class="external-link">https://doi.org/10.32614/CRAN.package.modelbased</a>.
</div>
<div id="ref-montieloleaSimultaneousConfidenceBands2019" class="csl-entry">
Montiel Olea, José Luis, and Mikkel Plagborg-Møller. 2019.
<span>“Simultaneous Confidence Bands: Theory, Implementation, and an
Application to SVARs.”</span> <em>Journal of Applied Econometrics</em>
34 (1): 1–17. <a href="https://doi.org/10.1002/jae.2656" class="external-link">https://doi.org/10.1002/jae.2656</a>.
</div>
<div id="ref-preacherAdvantagesMonteCarlo2012" class="csl-entry">
Preacher, Kristopher J., and James P. Selig. 2012. <span>“Advantages of
Monte Carlo Confidence Intervals for Indirect Effects.”</span>
<em>Communication Methods and Measures</em> 6 (2): 77–98. <a href="https://doi.org/10.1080/19312458.2012.679848" class="external-link">https://doi.org/10.1080/19312458.2012.679848</a>.
</div>
<div id="ref-rainey2017" class="csl-entry">
Rainey, Carlisle. 2017. <span>“Transformation-Induced Bias: Unbiased
Coefficients Do Not Imply Unbiased Quantities of Interest.”</span>
<em>Political Analysis</em> 25 (3): 402–9. <a href="https://doi.org/10.1017/pan.2017.11" class="external-link">https://doi.org/10.1017/pan.2017.11</a>.
</div>
<div id="ref-raineyCarefulConsiderationCLARIFY2023" class="csl-entry">
———. 2023. <span>“A Careful Consideration of <span>CLARIFY</span>:
Simulation-Induced Bias in Point Estimates of Quantities of
Interest.”</span> <em>Political Science Research and Methods</em>, 1–10.
<a href="https://doi.org/10.1017/psrm.2023.8" class="external-link">https://doi.org/10.1017/psrm.2023.8</a>.
</div>
<div id="ref-thulinModernStatisticsWrangling2021" class="csl-entry">
Thulin, Måns. 2024. <em>Modern Statistics with <span>R</span>: From
Wrangling and Exploring Data to Inference and Predictive Modelling</em>.
Second edition. Boca Raton, FL: CRC Press. <a href="https://www.modernstatisticswithr.com/" class="external-link">https://www.modernstatisticswithr.com/</a>.
</div>
<div id="ref-tofighiMonteCarloConfidence2016" class="csl-entry">
Tofighi, Davood, and David P. MacKinnon. 2016. <span>“Monte Carlo
Confidence Intervals for Complex Functions of Indirect Effects.”</span>
<em>Structural Equation Modeling: A Multidisciplinary Journal</em> 23
(2): 194–205. <a href="https://doi.org/10.1080/10705511.2015.1057284" class="external-link">https://doi.org/10.1080/10705511.2015.1057284</a>.
</div>
<div id="ref-tomzClarifySoftwareInterpreting2003" class="csl-entry">
Tomz, Michael, Jason Wittenberg, and Gary King. 2003. <span>“Clarify:
Software for Interpreting and Presenting Statistical Results.”</span>
<em>Journal of Statistical Software</em> 8 (January): 1–30. <a href="https://doi.org/10.18637/jss.v008.i01" class="external-link">https://doi.org/10.18637/jss.v008.i01</a>.
</div>
<div id="ref-zelnerUsingSimulationInterpret2009" class="csl-entry">
Zelner, Bennet A. 2009. <span>“Using simulation to interpret results
from logit, probit, and other nonlinear models.”</span> <em>Strategic
Management Journal</em> 30 (12): 1335–48. <a href="https://doi.org/10.1002/smj.783" class="external-link">https://doi.org/10.1002/smj.783</a>.
</div>
<div id="ref-zhouNoteBayesianInference2010" class="csl-entry">
Zhou, Xiang, and Jerome P. Reiter. 2010. <span>“A Note on Bayesian
Inference After Multiple Imputation.”</span> <em>The American
Statistician</em> 64 (2): 159–63. <a href="https://doi.org/10.1198/tast.2010.09109" class="external-link">https://doi.org/10.1198/tast.2010.09109</a>.
</div>
</div>
</div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Noah Greifer, Steven Worthington, Stefano Iacus, Gary King.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
