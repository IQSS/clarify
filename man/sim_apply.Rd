% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sim_apply.R
\name{sim_apply}
\alias{sim_apply}
\title{Apply a function to simulated parameter values}
\usage{
sim_apply(sim, FUN, verbose = TRUE, cl = NULL, ...)
}
\arguments{
\item{sim}{a `simbased_sim` object; the output of a call to `[sim()]`.}

\item{FUN}{a function to be applied to each set of simulated coefficients. See Details.}

\item{verbose}{`logical`; whether to display a text progress bar indicating progress and estimated time remaining for the procedure. Default is `TRUE`.}

\item{cl}{a cluster object created by `[parallel::makeCluster()]`, or an integer to indicate number of child-processes (integer values are ignored on Windows) for parallel evaluations. See `[pbapply::pblapply()]` for details. If `NULL`, no parallelization will take place.}

\item{...}{optional arguments passed to `FUN`.}
}
\value{
A `simbased_est` object, which is a matrix with a column for each estimated quantity and a row for each simulation. The original estimates (`FUN` applied to the original coefficients or model fit object) are stored in the attribute `"original"`. The `"sim_hash"` attributes contained the simulation hash produced by `sim()`.
}
\description{
`sim_apply()` applies a function that produces quantities of interest to each set of simulated coefficients produced by `[sim()]`; these calculated quantities form the posterior sampling distribution for the quantities of interest. Capabilities are available for parallelization.
}
\details{
`sim_apply()` applies a function to each set of simulated coefficients, similar to `[apply()]`. This function should produce an estimated quantity for which inference is to take place.

`FUN` should return a numeric vector containing one or more estimated quantities. This should be a named vector to more easily keep track of the meaning of each estimated quantity. Care should be taken to ensure that the returned vector is the same length each time `FUN` is called. `NA`s are allowed in the output but should be avoided if possible.

The arguments to `FUN` can be specified in a few ways. If `FUN` has an argument called `coefs`, a simulated set of coefficients will be passed to this argument, and `FUN` should compute and return a quantity based on the coefficients (e.g., the difference between two coefficients if one wants to test whether two coefficients are equal). If `FUN` has an argument called `fit`, a model fit object of the same type as the one originally supplied to `sim()` (e.g., an `lm` or `glm` object) will be passed to this argument, where the coefficients of the fit object have been replaced by the simulated coefficients generated by `sim()`, and `FUN` should compute and return a quantity based on the model fit (e.g., a computation based on the output of `predict()`). If neither `coefs` nor `fit` are the names of arguments to `FUN`, the model fit object with replaced coefficients will be supplied to the first argument of `FUN`.

When custom coefficients are supplied to `sim()`, i.e., when the `coefs` argument to `sim()` is not left at its default value, `FUN` must accept a `coefs` argument and a warning will be thrown if it accepts a `fit` argument. This is because `sim_apply()` does not know how to reconstruct the original fit object with the new coefficients inserted. The quantities computed by `sim_apply()` must therefore be computed directly from the coefficients.
}
\seealso{
`[sim()]` for generating the simulated coefficients, `[coef.simbased_est()]` and `[vcov.simbased_est()]` for extracting the estimates that their covariance matrix from a `simbased_est` object, `[cbind.simbased_est()]` and `[transform.simbased_est()]` for combining and transforming `simbased_est` objects, `[summary.simbased_est()]` for computing p-values and confidence intervals for the estimated quantities, `[sim_plot()]` for plotting simulated quantities and their simulated posterior sampling distribution.
}
